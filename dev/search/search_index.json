{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#species-interaction-networks","title":"Species Interaction Networks","text":""},{"location":"bibliography/","title":"Bibliography","text":""},{"location":"bibliography/#bibliography","title":"Bibliography","text":"Bastolla2009Architecture Ugo Bastolla, Miguel A. Fortuna, Alberto Pascual-Garc\u00eda, Antonio Ferrera, Bartolo Luque, Jordi Bascompte, The architecture of mutualistic networks minimizes competition and increases biodiversity, Nature, 458(7241), 1018\u20131020, 2009."},{"location":"community_level/nestedness/","title":"Nestedness","text":""},{"location":"community_level/nestedness/#nestedness","title":"Nestedness","text":"<p>Abstract</p> <p>The methods presented in this page measure the nestedness of a network. Nestedness is usually restricted to biparite networks.</p> <p></p> <p></p>"},{"location":"community_level/nestedness/#_1","title":"\u03b7","text":"<p>Degree distribution and \u03b7</p> <p>The \u03b7 measure of nestedness is invariant for a given degree distribution. In other words, two networks with the same (joint) degree distribution will always have the same value of \u03b7. As a result, network permutations using <code>swap!</code> and a constraint on the degree will not generate an appropriate null sample. This is also true when only one side on the degree distribution is maintained, for the measure of nestedness on this side.</p> <p># <code>SpeciesInteractionNetworks.\u03b7</code> \u2014 Function.</p> <pre><code>\u03b7(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Union{Binary, Probabilistic}}, dims::Integer = 0)\n</code></pre> <p>The \u03b7 measure of nestedness is a variation of NODF, it can be calculated at the scale of the entire network (using <code>0</code> as the second argument, which is the default), or for either side of the network (<code>1</code> for rows, <code>2</code> for columns).</p> <p>The measure for the entire network is the average of the nestedness of rows and columns.</p> <p>References</p> <p>Ugo Bastolla, Miguel A. Fortuna, Alberto Pascual-Garc\u00eda, Antonio Ferrera, Bartolo Luque, Jordi Bascompte (2009)</p> <p>source</p> <p></p> <p></p>"},{"location":"community_level/nestedness/#nodf","title":"NODF","text":""},{"location":"getting_started/demonstration/","title":"Building a network","text":""},{"location":"getting_started/demonstration/#building-a-network","title":"Building a network","text":"<p>Abstract</p> <p>Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual.</p> <pre><code>using SpeciesInteractionNetworks\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-species","title":"List of species","text":"<p>We will create a very small network, made of four species and their interactions. The first step is to define a list of species:</p> <pre><code>species = [:fox, :vole, :hawk, :turnip]\n</code></pre> <pre><code>4-element Vector{Symbol}:\n :fox\n :vole\n :hawk\n :turnip\n</code></pre> <p>In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite:</p> <pre><code>nodes = Unipartite(species)\n</code></pre> <pre><code>Unipartite{Symbol}([:fox, :vole, :hawk, :turnip])\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-interactions","title":"List of interactions","text":"<p>As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys.</p> <pre><code>int_matrix = Bool[\n0 1 0 0;\n0 0 0 1;\n0 1 0 0;\n0 0 0 0\n]\n</code></pre> <pre><code>4\u00d74 Matrix{Bool}:\n 0  1  0  0\n 0  0  0  1\n 0  1  0  0\n 0  0  0  0\n</code></pre> <p>About interaction as matrices</p> <p>By specifying interactions as a matrix, it is fundamental that columns and orders are in the correct order. There are alternative ways to specify networks that do not rely on matrices (using tuples or pairs), but because most species interaction network data are represented as matrices, this is supported by the package.</p> <p>As this network is binary, we will wrap this matrix into a <code>Binary</code> collection of interactions:</p> <pre><code>edges = Binary(int_matrix)\n</code></pre> <pre><code>Binary{Bool}(sparse([1, 3, 2], [2, 2, 4], Bool[1, 1, 1], 4, 4))\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#assembling-the-network","title":"Assembling the network","text":"<p>The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense.</p> <pre><code>network = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]), Binary{Bool}(sparse([1, 3, 2], [2, 2, 4], Bool[1, 1, 1], 4, 4)))\n</code></pre> <p>The networks are iterable, i.e. we can walk through them, specifically one interaction at a time:</p> <pre><code>for interaction in network\nprintln(interaction)\nend\n</code></pre> <pre><code>(:fox, :vole, true)\n(:hawk, :vole, true)\n(:vole, :turnip, true)\n</code></pre> <p>Internally, this is done by only returning the pairs of species that do not have a value of zero.</p> <p></p> <p></p>"},{"location":"getting_started/demonstration/#basics-of-network-exploration","title":"Basics of network exploration","text":"<p>We can also get a list of the species that establish an interaction with a given species (in this case, predators):</p> <pre><code>predecessors(network, :vole)\n</code></pre> <pre><code>Set{Symbol} with 2 elements:\n  :fox\n  :hawk\n</code></pre> <p>Or the species witch which a given species establishes interactions (in this case, preys):</p> <pre><code>successors(network, :fox)\n</code></pre> <pre><code>Set{Symbol} with 1 element:\n  :vole\n</code></pre> <p>Further</p> <pre><code>interactions(subgraph(network, [:fox, :vole, :turnip]))\n</code></pre> <pre><code>2-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-editable","title":"Networks are editable","text":"<p>The content of networks can be modified. For example, to circumvent the issue of needing to write the interaction matrix in the correct order, we can start with an empty network:</p> <pre><code>netsize = (richness(nodes,1), richness(nodes, 2))\nedges2 = Binary(zeros(Bool, netsize))\nnetwork2 = SpeciesInteractionNetwork(nodes, edges2)\ninteractions(network2)\n</code></pre> <pre><code>Tuple{Symbol, Symbol, Bool}[]\n</code></pre> <p>We can then add the interactions one by one:</p> <pre><code>for interaction in [(:fox, :vole), (:hawk, :vole), (:vole, :turnip)]\nnetwork2[interaction...] = true\nend\ninteractions(network2)\n</code></pre> <pre><code>3-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:hawk, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre>"},{"location":"getting_started/types/","title":"Type system","text":""},{"location":"getting_started/types/#the-type-system","title":"The type system","text":"<p>The package relies on a compreensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network.</p> <p>The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a <code>size</code> and <code>axes</code>, etc..</p> <p># <code>SpeciesInteractionNetworks.SpeciesInteractionNetwork</code> \u2014 Type.</p> <pre><code>SpeciesInteractionNetwork{P&lt;:Partiteness, E&lt;:Interactions}\n</code></pre> <p>A <code>SpeciesInteractionNetwork</code> type represents a species interaction network.</p> <p>This type has two fields: <code>nodes</code> (a <code>Partiteness</code>), and <code>edges</code> (an <code>Interactions</code>). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone.</p> <p>For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type</p> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}}\n</code></pre> <p>This enables very specialized dispatch and indexing thoughout the package.</p> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-species","title":"Representing species","text":"<p># <code>SpeciesInteractionNetworks.Partiteness</code> \u2014 Type.</p> <pre><code>Partiteness{T}\n</code></pre> <p>The species in a network are stored in a parametric sub-type of <code>Partiteness</code>. By default, this can be <code>Unipartite</code> or <code>Bipartite</code>. The inner type <code>T</code> indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Bipartite</code> \u2014 Type.</p> <pre><code>Bipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A bipartite set of species is represented by two sets of species, called <code>top</code> and <code>bottom</code>. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>top</code> must be unique</li> <li>All species in <code>bottom</code> must be unique</li> <li>No species can be found in both <code>bottom</code> and <code>top</code></li> </ol> <p>source</p> <p># <code>SpeciesInteractionNetworks.Unipartite</code> \u2014 Type.</p> <pre><code>Unipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A unipartite set of species is represented by a single set of species, called <code>margin</code> internally. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>margin</code> must be unique</li> </ol> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-interactions","title":"Representing interactions","text":"<p># <code>SpeciesInteractionNetworks.Interactions</code> \u2014 Type.</p> <pre><code>Interactions{T}\n</code></pre> <p>The interactions in a network are stored in a parametric sub-type of <code>Interactions</code>. By default, this can be <code>Binary</code>, <code>Quantitative</code>, and <code>Probabilistic</code>. The inner type <code>T</code> indicates what types are used to represent interactions.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Binary</code> \u2014 Type.</p> <pre><code>Binary{Bool} &lt;: Interactions{Bool}\n</code></pre> <p>Binary interactions are represented (internally) as a sparse matrix of Boolean values.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Quantitative</code> \u2014 Type.</p> <pre><code>Quantitative{T &lt;: Number} &lt;: Interactions{T}\n</code></pre> <p>Quantitative interactions are represented (internally) as a sparse matrix of numbers.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Probabilistic</code> \u2014 Type.</p> <pre><code>Probabilistic{T &lt;: AbstractFloat} &lt;: Interactions{T}\n</code></pre> <p>Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid.</p> <p>source</p>"},{"location":"random_networks/permutations/","title":"Permutations","text":""},{"location":"random_networks/permutations/#permutations-of-networks","title":"Permutations of networks","text":"<p>Abstract</p> <p>The methods presented in this page perform network permutation, i.e. they move interactions around while also respecting a number of constraints. Permutations are used in null hypothesis testing, or can be used alongside e.g. simulated annealing to bring networks closer to a specified structure.</p> <p>The functions for permutations are using an edge-swap algorithm, in which the endpoint of interactions is switched to re-wire the network without changing the degree distribution. Each call to the <code>swap!</code> function will modify the network, and perform a single edge swap.</p> <p>Maximum iterations when doing permutations</p> <p>Every permutation will try up to <code>SpeciesInteractionNetworks.SWAP_MAXITER</code> times (defaults to 100) to find a suitable pair of edges to swap, and then return the network unshuffled if they failed to find a suitable pair of edges to swap. This value can be changed.</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-constraints","title":"Permutation constraints","text":"<p>Permutations are constrained, in that we can guarantee that the resulting network may have structural properties that are similar to the original network. The type of constraint we apply is determined by the <code>PermutationConstrant</code> enumerated type.</p> <p># <code>SpeciesInteractionNetworks.PermutationConstraint</code> \u2014 Type.</p> <pre><code>PermutationConstraint\n</code></pre> <p>The <code>PermutationConstraint</code> specifies which structural constraint is enforced. It is defined as an abstract type, and the subtypes can be passed as the second argument to <code>swap!</code>.</p> <p>Currently supported constraints are <code>Degree</code> (degree distribution is maintained), <code>Generality</code> (number of out-going links is maintained), <code>Vulnerability</code> (number of in-going links is maintained), and <code>Connectance</code> (only the connectance is maintained). Note that in addition, species cannot become disconnected, even if the constraint is not acting on the degree / degree distribution.</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-of-a-network","title":"Permutation of a network","text":"<p>Note that the permutations are currently limited to networks with <code>Binary</code> interactions.</p> <p># <code>SpeciesInteractionNetworks.swap!</code> \u2014 Function.</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Performs one swap of interactions in the network. If no <code>PermutationConstraint</code> is given as a second argument, the degree distribution of all species will be maintained.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Degree})\n</code></pre> <p>Permutations with a constraint by degree work by picking two interacting species pairs, (r1, s1) and (r2, s2), and trying to replace them by (r1, s2) and (r2, s1).</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Generality})\n</code></pre> <p>Permutations with a constraint by degree work by picking one interacting species pair, (r1, s1), and a new stem species s3, trying to replace them by (r1, s3). This function only applies if the result of this permutations does not remove the last incoming link from s1.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Connectance})\n</code></pre> <p>Permutations with a constraint by connectance will randomly (and with equal probability) perform a move that is constrained by degree, generality, or vulnerability.</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#illustration","title":"Illustration","text":"<p>To showcase <code>swap!</code> in practice, we will work through through a simple example of (i) generating a perfectly nested network, (ii) shuffling interactions by maintaining the generality of top-level species, and (iii) looking at the way nestdeness of top and bottom level species changes with each successive swaps.</p> <pre><code>using SpeciesInteractionNetworks\nimport CairoMakie\nCairoMakie.activate!(px_per_unit=2)\n</code></pre> <p>We can generate a nested network rather easily, by creating a matrix of binary interactions, where the species interact with species from a lower rank:</p> <pre><code>A = zeros(Bool, (10, 14))\nfor i in axes(A, 1)\nfor j in axes(A, 2)\nif i &lt;= j\nA[i,j] = true\nend\nend\nend\n</code></pre> <p>We can declare a network without having to define all of the species, by first wrapping our matrix inside a <code>Binary</code> type, and then generating a <code>Bipartite</code> species set with the right number of species:</p> <pre><code>edges = Binary(A)\nnodes = Bipartite(edges)\nN = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Binary{Bool}}(Bipartite{Symbol}([:top_1, :top_2, :top_3, :top_4, :top_5, :top_6, :top_7, :top_8, :top_9, :top_10], [:bottom_1, :bottom_2, :bottom_3, :bottom_4, :bottom_5, :bottom_6, :bottom_7, :bottom_8, :bottom_9, :bottom_10, :bottom_11, :bottom_12, :bottom_13, :bottom_14]), Binary{Bool}(sparse([1, 1, 2, 1, 2, 3, 1, 2, 3, 4  \u2026  1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10, 14)))\n</code></pre> <p>The initial nestedness of this network is (network, top-level contribution, bottom-level contribution):</p> <pre><code>(\u03b7(N), \u03b7(N,1), \u03b7(N,2))\n</code></pre> <pre><code>(1.0, 1.0, 1.0)\n</code></pre> <p>In order to generate the series of successive permutations, we will define an empty array of values, and then for each successive step, calculate the nestedness of the network, and then swap interactions under the given constraint.</p> <pre><code>nestedness_series = zeros(Float64, 1000)\nfor i in axes(nestedness_series, 1)\nnestedness_series[i] = \u03b7(N)\nswap!(N, Generality)\nend\n</code></pre> <p>A note about swaps and underlying nodes/edges</p> <p>When we perform the <code>swap!</code> operation, we are modifying the network (this is what we want!), but we are also modifying the <code>edges</code> object. If you want to re-use the edges in another network, be mindful of the fact that this will be the randomized edges.</p> <p>Finally, we can plot the result, to check that 1000 swaps are enough to bring us to some sort of equilibrium of the randomized nestedness:</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Swap\", ylabel = \"Nestedness\")\nCairoMakie.lines!(ax, nestedness_series, color=(:black, 0.5))\nCairoMakie.tightlimits!(ax)\nCairoMakie.current_figure()\n</code></pre> <p></p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#species-interaction-networks","title":"Species Interaction Networks","text":"<p>The <code>SpeciesInteractionNetworks</code> package enables analyses of species interaction networks in Julia. The list of implemented measures (and more broadly, the design of the package) closely follows the recommendations in Delmas et al. (2019).</p> <p>The measures in the documentation are organized by level of organisation, following a simple convention. Micro-level measures return information at the level of the node. Typically, these will return a value for each species in the network. Meso-level measures return information about more than one species, but not about the entire network. Examples are shortest paths, motif enumeration, etc. Macro-level measures are summaries of the entire network, and typically return one value for the entire network. Finally, meta-level measures are intended to be applied to a collection of networks; network dissimilarity measures are one example.</p> <p>This package is a library for the analysis of ecological networks. On purpose, we do not provide \"wrapper\"-type functions that would perform an entire analysis. We experimented with this idea during development, and rapidly realized that even for the most simple research project, we needed to make small tweaks that made the wrappers a nuisance. We decided to give you the parts, and it's your job to build the kick-ass spaceship.</p> <p>The package is built around a type system for species interaction networks, which is intended to capture the different types of data and communities ecologists need to handle. This makes the package extensible, both by writing additional methods with a very fine-tuned dispatch, or by adding additional types that should work out of the box (or be very close to).</p> <p>Why a new package?</p> <p>This package is a re-master (director's cut?) of <code>EcologicalNetworks</code>. Why? Code rot, experience, and truth in advertising. <code>EcologicalNetworks</code> was initially written in the days of Julia 0.5, and never really caught up with changes in the language (or with accumulated experience in writing code that is easy to maintain). After realizing the the former's type system was often preventing elegant dispatch and was due for a re-write, it made sense to initiate a susbtantial refactor. Additionally, there are ecological networks that do not describe species interactions, which were not covered by the package.</p>"},{"location":"bibliography/","title":"Bibliography","text":""},{"location":"bibliography/#bibliography","title":"Bibliography","text":"<ul><li> Almeida-Neto, M.; Guimar{\u00e3}es, P.; Guimar{\u00e3}es, P. R.; Loyola, R. D. and Ulrich, W. (2008). A consistent metric for nestedness analysis in ecological systems: reconciling concept and measurement. Oikos 117, 1227\u20131239. </li><li> Almeida-Neto, M. and Ulrich, W. (2011). A straightforward computational approach for measuring nestedness using quantitative matrices. Environmental Modelling {\\&amp;}amp$\\mathsemicolon$ Software 26, 173\u2013178. </li><li> Bascompte, J.; Jordano, P.; Meli\u00e1n, C. J. and Olesen, J. M. (2003). The nested assembly of plant\u2013animal mutualistic networks. Proceedings of the National Academy of Sciences 100, 9383\u20139387. </li><li> Bastolla, U.; Fortuna, M. A.; Pascual-Garc\u00eda, A.; Ferrera, A.; Luque, B. and Bascompte, J. (2009). The architecture of mutualistic networks minimizes competition and increases biodiversity. Nature 458, 1018\u20131020. </li><li> Bavelas, A. (1950). Communication Patterns in Task\u2010Oriented Groups. The Journal of the Acoustical Society of America 22, 725\u2013730. </li><li> Canard, E. F.; Mouquet, N.; Mouillot, D.; Stanko, M.; Miklisova, D. and Gravel, D. (2014). Empirical Evaluation of Neutral Interactions in Host-Parasite Networks. The American Naturalist 183, 468\u2013479. </li><li> Cody, M. L. (1975). Ecology and Evolution of Communities. Towards a theory of continental species diversities: bird distributions over Mediterranean habitat gradients, Belknap Press. </li><li> Dangalchev, C. (2006). Residual closeness in networks. Physica A 365, 556\u2013564. </li><li> Dangalchev, C. (2011). Residual Closeness and Generalized Closeness. International Journal of Foundations of Computer Science 22, 1939\u20131948. </li><li> Delmas, E.; Besson, M.; Brice, M.-H.; Burkle, L. A.; Riva, G. V.; Fortin, M.-J.; Gravel, D.; Guimar\u00e3es, P. R.; Hembry, D. H.; Newman, E. A.; Olesen, J. M.; Pires, M. M.; Yeakel, J. D. and Poisot, T. (2019). Analysing ecological networks of species interactions. Biological Reviews 94, 16\u201336. </li><li> Dupont, Y. L.; Hansen, D. M. and Olesen, J. M. (2003). Structure of a plant-flower-visitor network in the high-altitude sub-alpine desert of Tenerife, Canary Islands. Ecography 26, 301\u2013310. </li><li> Fortuna, M. A. and Bascompte, J. (2006). Habitat loss and the structure of plant-animal mutualistic networks. Ecology Letters 9, 281\u2013286. </li><li> Harrison, S.; Ross, S. J. and Lawton, J. H. (1992). Beta Diversity on Geographic Gradients in Britain. The Journal of Animal Ecology 61, 151. </li><li> Junker, B. H. and Schreiber, F. (2008). Analysis of Biological Networks. Wiley. </li><li> Katz, L. (1953). A new status index derived from sociometric analysis. Psychometrika 18, 39\u201343. </li><li> Koleff, P.; Gaston, K. J. and Lennon, J. J. (2003). Measuring beta diversity for presence-absence data. Journal of Animal Ecology 72, 367\u2013382. </li><li> Landau, E. (1895). Zur relativen Wertbemessung der Turnierresultate. Deutsches Wochenschach 11, 366\u2013369. </li><li> Magurran, A. E. (1988). Ecological diversity and its measurement. Princeton university press. </li><li> Martinez, N. D. (1992). Constant Connectance in Community Food Webs. The American Naturalist 139, 1208\u20131218. </li><li> Phillips, J. D. (2011). The structure of ecological state transitions: Amplification, synchronization, and constraints in responses to environmental change. Ecological Complexity 8, 336\u2013346. </li><li> Poisot, T.; Stanko, M.; Miklisov{\u00e1}, D. and Morand, S. (2013). Facultative and obligate parasite communities exhibit different network properties. Parasitology 140, 1340\u20131345. </li><li> Poisot, T. (2022). Dissimilarity of species interaction networks: quantifying the effect of turnover and rewiring. Peer Community Journal 2. </li><li> Poisot, T.; Canard, E.; Mouillot, D.; Mouquet, N. and Gravel, D. (2012). The dissimilarity of species interaction networks. Ecology Letters 15, 1353\u20131361. </li><li> Poisot, T.; Canard, E.; Mouquet, N. and Hochberg, M. E. (2012). A comparative study of ecological specialization estimators. Methods in Ecology &amp; Evolution 3, 537\u2013544. </li><li> Poisot, T.; Cirtwill, A.; Cazelles, K.; Gravel, D.; Fortin, M.-J. and Stouffer, D. (2015). The structure of probabilistic networks. Methods in Ecology and Evolution 7, 303\u2013312. </li><li> Saavedra, S.; Stouffer, D. B.; Uzzi, B. and Bascompte, J. (2011). Strong contributors to network persistence are the most vulnerable to extinction. Nature 478, 233\u2013235. </li><li> Schoener, T. W. (1989). Food Webs From the Small to the Large: The Robert H. MacArthur Award Lecture. Ecology 70, 1559\u20131589. </li><li> Southwood, T. R. and Henderson, P. A. (2009). Ecological methods. John Wiley \\&amp; Sons. </li><li> Staniczenko, P. P.; Kopp, J. C. and Allesina, S. (2013). The ghost of nestedness in ecological networks. Nature Communications 4. </li><li> Stock, M.; Poisot, T.; Waegeman, W. and Baets, B. D. (2017). Linear filtering reveals false negatives in species interaction data. Scientific Reports 7. </li><li> Weitz, J. S.; Poisot, T.; Meyer, J. R.; Flores, C. O.; Valverde, S.; Sullivan, M. B. and Hochberg, M. E. (2013). Phage{\\textendash}bacteria infection networks. Trends in Microbiology 21, 82\u201391. </li><li> Whittaker, R. H. (1960). Vegetation of the Siskiyou Mountains, Oregon and California. Ecological Monographs 30, 279\u2013338. </li><li> Williams, R. J. and Martinez, N. D. (2000). Simple rules yield complex food webs. Nature 404, 180\u2013183. </li><li> Wilson, M. V. and Shmida, A. (1984). Measuring Beta Diversity with Presence-Absence Data. The Journal of Ecology 72, 1055. </li> </ul>"},{"location":"internals/","title":"Internals","text":""},{"location":"internals/#internals","title":"Internals","text":""},{"location":"internals/#network-dimensions","title":"Network dimensions","text":""},{"location":"internals/#copy-of-network-data","title":"Copy of network data","text":"<p># <code>Base.copy</code> \u2014 Method.</p> <pre><code>Base.copy(N::SpeciesInteractionNetwork)\n</code></pre> <p>A copy of a network is created by wrapping together a copy of the nodes and a copy of the edges.</p> <p>source</p>"},{"location":"getting_started/basics/","title":"Basic descriptors","text":""},{"location":"getting_started/basics/#basic-information-on-networks","title":"Basic information on networks","text":"<p># <code>SpeciesInteractionNetworks.species</code> \u2014 Function.</p> <pre><code>species(N::Bipartite)\n</code></pre> <p>Returns the list of species in a bipartite list of nodes, as a single vector.</p> <p>source</p> <pre><code>species(N::Unipartite)\n</code></pre> <p>Returns the list of species in a unipartite list of nodes, as a single vector.</p> <p>source</p> <pre><code>species(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns the list of species in a network, by calling the <code>species</code> method corresponding to the appropriate species list.</p> <p>source</p> <pre><code>species(N::SpeciesInteractionNetwork, dims::Integer)\n</code></pre> <p>Returns the list of species on the top (<code>1</code> as last argument) or bottom (<code>2</code> as second argument) for the network. For unipartite networks, this will return the same list of species.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.richness</code> \u2014 Function.</p> <pre><code>richness(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns the number of species in a network, measured as the length of the species items.</p> <p>source</p> <pre><code>richness(N::SpeciesInteractionNetwork, dims::Integer)\n</code></pre> <p>Returns the number of species in a network, either on the top (<code>1</code> as last argument) or bottom (<code>2</code> as last argument), measured as the length of the species items on this side.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.interactions</code> \u2014 Function.</p> <pre><code>interactions(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns a vector of all interactions in the network.</p> <p>Each interactions is returned an un-named tuple of three elements: the source, the destination, and the value. For a binary network, for example, an interaction from <code>:a</code> to <code>:b</code> will be represented as <code>(:a,:b,true)</code>. The type of the tuple that is returned is given by <code>eltype(N)</code>, and is the same as the output of using iteration on a network.</p> <p>Note that this method is substantially faster and more memory-efficient than using iteration (<code>int for int in N</code>), for reasons related to the indexing of non-zero interactions in the underlying data structure of the network.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.predecessors</code> \u2014 Function.</p> <pre><code>predecessors(N::SpeciesInteractionNetwork{Bipartite{T}, &lt;:Interactions}, sp::T) where {T}\n</code></pre> <p>The predecessors of a species in a bipartite network is the list of all species it receives a non-zero interaction from. For probabilistic networks, this includes all species with a non-zero probability of interaction.</p> <p>If the species is at the top of the network, or if the specis has no predecessors, this method will retun an empty list of species, specifically <code>Set{T}()</code>.</p> <p>source</p> <pre><code>predecessors(N::SpeciesInteractionNetwork{Unipartite{T}, &lt;:Interactions}, sp::T) where {T}\n</code></pre> <p>The predecessors of a species in a unipartite network is the list of all species it receives a non-zero interaction from. For probabilistic networks, this includes all species with a non-zero probability of interaction.</p> <p>If the specis has no predecessors, this method will retun an empty list of species, specifically <code>Set{T}()</code>.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.successors</code> \u2014 Function.</p> <pre><code>successors(N::SpeciesInteractionNetwork{Bipartite{T}, &lt;:Interactions}, sp::T) where {T}\n</code></pre> <p>The successors of a species in a bipartite network is the list of all species it establishes a non-zero interaction with. For probabilistic networks, this includes all species with a non-zero probability of interaction.</p> <p>If the species is at the bottom of the network, or if the specis has no successors, this method will retun an empty list of species, specifically <code>Set{T}()</code>.</p> <p>source</p> <pre><code>successors(N::SpeciesInteractionNetwork{Unipartite{T}, &lt;:Interactions}, sp::T) where {T}\n</code></pre> <p>The successors of a species in a unipartite network is the list of all species it establishes a non-zero interaction with. For probabilistic networks, this includes all species with a non-zero probability of interaction.</p> <p>If the specis has no successors, this method will retun an empty list of species, specifically <code>Set{T}()</code>.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.neighbors</code> \u2014 Function.</p> <pre><code>neighbors(N::SpeciesInteractionNetwork{&lt;:Partiteness{T}, &lt;:Interactions}) where {T}\n</code></pre> <p>The neighbors of a species is the list of both its successors and prde</p> <p>source</p>"},{"location":"getting_started/demonstration/","title":"Building a network","text":""},{"location":"getting_started/demonstration/#building-a-network","title":"Building a network","text":"<p>Abstract</p> <p>Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual.</p> <p>To begin with, we will load the package:</p> <pre><code>using SpeciesInteractionNetworks\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#creating-a-list-of-species","title":"Creating a list of species","text":"<p>We will create a very small network, made of four species and their interactions. The first step is to define a list of species:</p> <pre><code>species = [:fox, :vole, :hawk, :turnip]\n</code></pre> <pre><code>4-element Vector{Symbol}:\n :fox\n :vole\n :hawk\n :turnip\n</code></pre> <p>In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite, using the <code>Unipartite</code> constructor:</p> <pre><code>nodes = Unipartite(species)\n</code></pre> <pre><code>Unipartite{Symbol}([:fox, :vole, :hawk, :turnip])\n</code></pre> <p>Note that the package is not considering information about the ecological nature of the interaction, only (i) the structure of the community, as captured by its <code>Partiteness</code>, and later on about its <code>Interactions</code>.</p> <p></p> <p></p>"},{"location":"getting_started/demonstration/#creating-interactions","title":"Creating interactions","text":"<p>As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys.</p> <pre><code>int_matrix = Bool[\n0 1 0 0;\n0 0 0 1;\n0 1 0 0;\n0 0 0 0\n]\n</code></pre> <pre><code>4\u00d74 Matrix{Bool}:\n 0  1  0  0\n 0  0  0  1\n 0  1  0  0\n 0  0  0  0\n</code></pre> <p>About interaction as matrices</p> <p>By specifying interactions as a matrix, it is fundamental that columns and orders are in the correct order. There are alternative ways to specify networks that do not rely on matrices (using tuples or pairs), but because most species interaction network data are represented as matrices, this is supported by the package.</p> <p>As this network is binary, we will wrap this matrix into a <code>Binary</code> collection of interactions:</p> <pre><code>edges = Binary(int_matrix)\n</code></pre> <pre><code>Binary{Bool}(sparse([1, 3, 2], [2, 2, 4], Bool[1, 1, 1], 4, 4))\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#assembling-the-network","title":"Assembling the network","text":"<p>The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense. These checks are done when calling <code>SpeciesInteractionNetwork</code>, which is the main type around which the package is built.</p> <pre><code>network = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>A binary unipartite network\n \u2192 3 interactions\n \u2192 4 species\n</code></pre> <p>The networks are iterable, i.e. we can walk through them, specifically one interaction at a time:</p> <pre><code>for interaction in network\nprintln(interaction)\nend\n</code></pre> <pre><code>(:fox, :vole, true)\n(:hawk, :vole, true)\n(:vole, :turnip, true)\n</code></pre> <p>Internally, this is done by only returning the pairs of species that do not have a value of zero. There is a way to capture all of the interactions at a time, using <code>interactions</code> \u2013 this solution is faster than direct iteraction, potentially by a few orders of magnitude.</p> <pre><code>interactions(network)\n</code></pre> <pre><code>3-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n (:hawk, :vole, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#basics-of-network-exploration","title":"Basics of network exploration","text":"<p>We can also get a list of the species that establish an interaction with a given species (in this case, predators):</p> <pre><code>predecessors(network, :vole)\n</code></pre> <pre><code>Set{Symbol} with 2 elements:\n  :fox\n  :hawk\n</code></pre> <p>Or the species witch which a given species establishes interactions (in this case, preys):</p> <pre><code>successors(network, :fox)\n</code></pre> <pre><code>Set{Symbol} with 1 element:\n  :vole\n</code></pre> <p>Furthermore, we can return a subset (or more accurately a <code>subgraph</code>) of the network, by giving a list of species:</p> <pre><code>interactions(subgraph(network, [:fox, :vole, :turnip]))\n</code></pre> <pre><code>2-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-editable","title":"Networks are editable","text":"<p>The content of networks can be modified. For example, to circumvent the issue of needing to write the interaction matrix in the correct order, we can start with an empty network:</p> <pre><code>netsize = (richness(nodes,1), richness(nodes, 2))\nedges2 = Binary(zeros(Bool, netsize))\nnetwork2 = SpeciesInteractionNetwork(nodes, edges2)\ninteractions(network2)\n</code></pre> <pre><code>Tuple{Symbol, Symbol, Bool}[]\n</code></pre> <p>We can then add the interactions one by one:</p> <pre><code>for interaction in [(:fox, :vole), (:hawk, :vole), (:vole, :turnip)]\nnetwork2[interaction...] = true\nend\ninteractions(network2)\n</code></pre> <pre><code>3-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n (:hawk, :vole, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-tables","title":"Networks are tables","text":"<p>All of the networks can be converted to a tabular data, for use with e.g. the <code>DataFrames</code> package:</p> <pre><code>import DataFrames\nDataFrames.DataFrame(network)\n</code></pre> 3\u00d73 DataFrame Row123SymbolSymbolBool1foxvoletrue2voleturniptrue3hawkvoletrue <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-broadcastable","title":"Networks are broadcastable","text":"<p>We can use the broadcast syntax to rapidly apply operations to all positions in a network. Note that this is not only applying operations to the positions that are non-zero. For example, we can flip the sign of all interactions in the network:</p> <pre><code>interactions(.!network)\n</code></pre> <pre><code>13-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :fox, 1)\n (:fox, :hawk, 1)\n (:fox, :turnip, 1)\n (:vole, :fox, 1)\n (:vole, :vole, 1)\n (:vole, :hawk, 1)\n (:hawk, :fox, 1)\n (:hawk, :hawk, 1)\n (:hawk, :turnip, 1)\n (:turnip, :fox, 1)\n (:turnip, :vole, 1)\n (:turnip, :hawk, 1)\n (:turnip, :turnip, 1)\n</code></pre> <p>In the same way, we can broadcast operations on pairs of networks. In this case, the constraint that will be enforced is that the species must be the same (they do not need to be in the same order, however):</p> <pre><code>interactions(network .+ network)\n</code></pre> <pre><code>3-element Vector{Tuple{Symbol, Symbol, Int64}}:\n (:fox, :vole, 2)\n (:vole, :turnip, 2)\n (:hawk, :vole, 2)\n</code></pre> <p>In practice, the application of broadcasting to network is of limited value, but the package offers the ability to do it.</p>"},{"location":"getting_started/types/","title":"Type system","text":""},{"location":"getting_started/types/#the-type-system","title":"The type system","text":"<p>The package relies on a comprehensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network.</p> <p>The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a <code>size</code> and <code>axes</code>, etc..</p> <p># <code>SpeciesInteractionNetworks.SpeciesInteractionNetwork</code> \u2014 Type.</p> <pre><code>SpeciesInteractionNetwork{P&lt;:Partiteness, E&lt;:Interactions}\n</code></pre> <p>A <code>SpeciesInteractionNetwork</code> type represents a species interaction network.</p> <p>This type has two fields: <code>nodes</code> (a <code>Partiteness</code>), and <code>edges</code> (an <code>Interactions</code>). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone.</p> <p>For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type</p> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}}\n</code></pre> <p>This enables very specialized dispatch and indexing thoughout the package.</p> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-species","title":"Representing species","text":"<p># <code>SpeciesInteractionNetworks.Partiteness</code> \u2014 Type.</p> <pre><code>Partiteness{T}\n</code></pre> <p>The species in a network are stored in a parametric sub-type of <code>Partiteness</code>. By default, this can be <code>Unipartite</code> or <code>Bipartite</code>. The inner type <code>T</code> indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Bipartite</code> \u2014 Type.</p> <pre><code>Bipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A bipartite set of species is represented by two sets of species, called <code>top</code> and <code>bottom</code>. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>top</code> must be unique</li> <li>All species in <code>bottom</code> must be unique</li> <li>No species can be found in both <code>bottom</code> and <code>top</code></li> </ol> <p>source</p> <p># <code>SpeciesInteractionNetworks.Unipartite</code> \u2014 Type.</p> <pre><code>Unipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A unipartite set of species is represented by a single set of species, called <code>margin</code> internally. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>margin</code> must be unique</li> </ol> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-interactions","title":"Representing interactions","text":"<p># <code>SpeciesInteractionNetworks.Interactions</code> \u2014 Type.</p> <pre><code>Interactions{T}\n</code></pre> <p>The interactions in a network are stored in a parametric sub-type of <code>Interactions</code>. By default, this can be <code>Binary</code>, <code>Quantitative</code>, and <code>Probabilistic</code>. The inner type <code>T</code> indicates what types are used to represent interactions.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Binary</code> \u2014 Type.</p> <pre><code>Binary{Bool} &lt;: Interactions{Bool}\n</code></pre> <p>Binary interactions are represented (internally) as a sparse matrix of Boolean values.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Quantitative</code> \u2014 Type.</p> <pre><code>Quantitative{T &lt;: Number} &lt;: Interactions{T}\n</code></pre> <p>Quantitative interactions are represented (internally) as a sparse matrix of numbers.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Probabilistic</code> \u2014 Type.</p> <pre><code>Probabilistic{T &lt;: AbstractFloat} &lt;: Interactions{T}\n</code></pre> <p>Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid.</p> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#type-conversion","title":"Type conversion","text":"<p># <code>SpeciesInteractionNetworks.render</code> \u2014 Function.</p> <pre><code>render(::Type{Unipartite}, N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Interactions})\n</code></pre> <p>Returns the unipartite projection of a bipartite network. By constructions, species cannot be shared between levels of bipartite network, so this operation will always succeed.</p> <p>source</p> <pre><code>render(::Type{Quantitative{T}}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Interactions}) where {T &lt;: Number}\n</code></pre> <p>Returns a quantitative version of the network, where interaction strengths have the type <code>T</code>. This can be used to convert a quantitative network into a different number representation.</p> <p>source</p> <pre><code>render(::Type{Probabilistic{T}}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Interactions}) where {T &lt;: AbstractFloat}\n</code></pre> <p>Returns a probabilistic version of the network, where interaction probabilities have the type <code>T</code>. This can be used to convert a probabilistic network into a different number representation.</p> <p>source</p> <pre><code>render(::Type{Binary}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Interactions})\n</code></pre> <p>Returns a binary version of the network, where the non-zero interactions are <code>true</code>.</p> <p>source</p>"},{"location":"macro_level/degeneracy/","title":"Disconnected species","text":""},{"location":"macro_level/degeneracy/#disconnected-species","title":"Disconnected species","text":"<p>Abstract</p> <p>When generating networks, in particular when using <code>randomdraws</code> following <code>nullmodel</code>, there is a chance that some species will have no interactions. In some cases, it may be relevant to identify and remove these species. The methods presented in this page offer a way to do this.</p> <p></p> <p></p>"},{"location":"macro_level/degeneracy/#detection-of-disconnected-species","title":"Detection of disconnected species","text":"<p># <code>SpeciesInteractionNetworks.isdisconnected</code> \u2014 Function.</p> <pre><code>isdisconnected(N::SpeciesInteractionNetwork{Bipartite{T}, &lt;:Interactions}, sp::T) where {T}\n</code></pre> <p>Returns <code>true</code> if the species has no interaction.</p> <p>source</p> <pre><code>isdisconnected(N::SpeciesInteractionNetwork{Unipartite{T}, &lt;:Interactions}, sp::T, allow_self_interactions::Bool=true) where {T}\n</code></pre> <p>Returns <code>true</code> if the species has no interaction; the last argument (<code>allow_self_interactions</code>, defaults to <code>true</code>) indicates whether self-interactions are allowed. If <code>false</code>, species that only interact with themselves are considered to be disconnected.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.isdegenerate</code> \u2014 Function.</p> <pre><code>isdegenerate(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Interactions})\n</code></pre> <p>A bipartite network is degenerate if it has species with no interactions.</p> <p>source</p> <pre><code>isdegenerate(N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Interactions}, allow_self_interactions::Bool=true)\n</code></pre> <p>A unipartite network is degenerate if it has species with no interactions. In some cases, it is useful to consider that a species with only self-interactions is disconnected from the network \u2013 this can be done by using <code>false</code> as the second argument (the default is to allow species with only self interactions to remain).</p> <p>source</p> <p></p> <p></p>"},{"location":"macro_level/degeneracy/#simplification-of-networks-with-disconnected-species","title":"Simplification of networks with disconnected species","text":"<p># <code>SpeciesInteractionNetworks.simplify</code> \u2014 Function.</p> <pre><code>simplify(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Interactions})\n</code></pre> <p>Returns a copy of a network containing only the species with interactions. Internally, this calls <code>isdisconnected</code>.</p> <p>source</p> <pre><code>simplify(N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Interactions}, allow_self_interactions::Bool=true)\n</code></pre> <p>Returns a copy of a network containing only the species with interactions. Internally, this calls <code>isdisconnected</code> \u2013 see this documentation for the consequences of <code>allow_self_interactions</code>.</p> <p>source</p> <p>Where is <code>simplify!</code></p> <p>In the <code>EcologicalNetworks.jl</code> package, the <code>simplify!</code> function would drop species from a network. In this package, because we try to keep networks as immutable as possible, we have not implemented this function. If you really want to reproduce this behavior, you can wrap whatever command will create the network in <code>simplify</code>.</p>"},{"location":"macro_level/links/","title":"Links counting","text":""},{"location":"macro_level/links/#links-counting","title":"Links counting","text":"<p>Abstract</p> <p>TODO</p> <p></p> <p></p>"},{"location":"macro_level/links/#number-of-links","title":"Number of links","text":"<p># <code>SpeciesInteractionNetworks.links</code> \u2014 Function.</p> <pre><code>links(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Interactions})\n</code></pre> <p>The number of links in a network is defined as the number of non-zero elements in the network. For quantitative networks, this is not weighted by the intensity of each interaction.</p> <p>source</p> <pre><code>links(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Probabilistic})\n</code></pre> <p>The number of links in a probabilistic network is defined as the expected number of interactions in the network. See also <code>links_variance</code>.</p> <p>References</p> <p>Poisot, Cirtwill, Cazelles, Gravel, Fortin and Stouffer (2015)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.connectance</code> \u2014 Function.</p> <pre><code>connectance(N::SpeciesInteractionNetwork)\n</code></pre> <p>The connectance, also known as the density, of a network is defined as the ratio between the number of existing links and the number of possible links. This value is in the unit interval. For a probabilistic network, this returns the expected connectance.</p> <p>References</p> <p>Martinez (1992)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.linkagedensity</code> \u2014 Function.</p> <pre><code>connectance(N::SpeciesInteractionNetwork)\n</code></pre> <p>The linkage density of a network is the average number of interaction per species (or its expected value in the case of probabilistic networks).</p> <p>source</p> <p></p> <p></p>"},{"location":"macro_level/links/#variances-for-probabilistic-networks","title":"Variances for probabilistic networks","text":"<p># <code>SpeciesInteractionNetworks.links_variance</code> \u2014 Function.</p> <pre><code>links_variance(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Probabilistic})\n</code></pre> <p>The variance in the expected number of links in a probabilistic network is defined as the sum of $p \\times (1 - p)$, where $p$ is the probability of all interactions (including $p = 0$).</p> <p>References</p> <p>Poisot, Cirtwill, Cazelles, Gravel, Fortin and Stouffer (2015)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.connectance_variance</code> \u2014 Function.</p> <pre><code>connectance_variance(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Probabilistic})\n</code></pre> <p>See also <code>connectance</code>.</p> <p>References</p> <p>Poisot, Cirtwill, Cazelles, Gravel, Fortin and Stouffer (2015)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.linkagedensity_variance</code> \u2014 Function.</p> <pre><code>linkagedensity_variance(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Probabilistic})\n</code></pre> <p>See also <code>linkagedensity_variance</code>.</p> <p>References</p> <p>Poisot, Cirtwill, Cazelles, Gravel, Fortin and Stouffer (2015)</p> <p>source</p>"},{"location":"macro_level/nestedness/","title":"Nestedness","text":""},{"location":"macro_level/nestedness/#nestedness","title":"Nestedness","text":"<p>Abstract</p> <p>The methods presented in this page measure the nestedness of a network. Nestedness is usually restricted to biparite networks, although following the arguments laid out by Staniczenko et al. (2013), we consider <code>spectralradius</code> to be a measure of nestedness.</p> <p></p> <p></p>"},{"location":"macro_level/nestedness/#_1","title":"\u03b7","text":"<p>Degree distribution and \u03b7</p> <p>The \u03b7 measure of nestedness is invariant for a given degree distribution. In other words, two networks with the same (joint) degree distribution will always have the same value of \u03b7. As a result, network permutations using <code>swap!</code> and a constraint on the degree will not generate an appropriate null sample. This is also true when only one side on the degree distribution is maintained, for the measure of nestedness on this side.</p> <p># <code>SpeciesInteractionNetworks.\u03b7</code> \u2014 Function.</p> <pre><code>\u03b7(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Union{Binary, Probabilistic}})\n</code></pre> <p>The \u03b7 measure of nestedness is a variation of NODF, at the scale of the entire network. The measure for the entire network is the average of the nestedness of rows and columns.</p> <p>References</p> <p>Bastolla, Fortuna, Pascual-Garc\u00eda, Ferrera, Luque and Bascompte (2009)</p> <p>source</p> <pre><code>\u03b7(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Union{Binary, Probabilistic}}, dims::Integer)\n</code></pre> <p>The \u03b7 measure of nestedness is a variation of NODF, it can be calculated for either side of the network (<code>1</code> for rows, <code>2</code> for columns).</p> <p>References</p> <p>Bastolla, Fortuna, Pascual-Garc\u00eda, Ferrera, Luque and Bascompte (2009)</p> <p>source</p> <p></p> <p></p>"},{"location":"macro_level/nestedness/#nodf","title":"NODF","text":"<p># <code>SpeciesInteractionNetworks.nodf</code> \u2014 Function.</p> <pre><code>nodf(N::T; dims::Union{Nothing,Integer}=nothing) where {T &lt;: Union{BipartiteNetwork,BipartiteQuantitativeNetwork}}\n</code></pre> <p>Returns <code>nodf</code> for a margin of the network. The <code>i</code> argument can be 1 for top-level, 2 for bottom level, and the function will throw an <code>ArgumentError</code> if an invalid value is used. For quantitative networks, WNODF is used.</p> <p>References</p> <p>Almeida-Neto, Guimar{\u00e3}es, Guimar{\u00e3}es, Loyola and Ulrich (2008)</p> <p>Almeida-Neto and Ulrich (2011)</p> <p>source</p> <p></p> <p></p>"},{"location":"macro_level/nestedness/#spectral-radius","title":"Spectral radius","text":"<p># <code>SpeciesInteractionNetworks.spectralradius</code> \u2014 Function.</p> <pre><code>spectralradius(N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary}; correction=:links)\n</code></pre> <p>The spectral radius of a unipartite is a conceptual equivalent to nestedness (Staniczenko et al., 2013). It is defined as the absolute value of the largest real part of the eigenvalues of the undirected adjacency matrix.</p> <p>There are a number of corrections available through the <code>correction</code> keyword.</p> <p>The default correction is <code>:links</code> as in Staniczenko et al. (2013), where the values are divided by the square root of the number of links, excluding the self-interactions.</p> <p>Using the <code>:connectance</code> correction follows the version of Phillips (2011), where the values are divided by the square root of $(L\\times(S-1))S^{-1}$ (this is not quite connectance, but the point is that this version is corrected for network size and order).</p> <p>Using <code>:none</code> returns the raw values, and for the sake of comparisons across networks, it is advised not to use it. It is included for cases where the networks to compare have the same number of species and interactions, as in this case it is appropriate and slightly faster than other corrections.</p> <p>References</p> <p>Phillips (2011)</p> <p>Staniczenko, Kopp and Allesina (2013)</p> <p>source</p> <pre><code>spectralradius(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Binary}; kwargs...)\n</code></pre> <p>The bipartite version of <code>spectralradius</code> is measured by first projecting the bipartite network as a unipartite one using <code>render</code>. The same options as for the unipartite version are then applied.</p> <p>source</p>"},{"location":"meso_level/paths/","title":"Paths","text":""},{"location":"meso_level/paths/#paths","title":"Paths","text":"<p>Abstract</p> <p>These functions help with path manipulation, and in particular the identification of shortest paths between any two nodes.</p> <p></p> <p></p>"},{"location":"meso_level/paths/#shortest-path-calculation","title":"Shortest path calculation","text":"<p># <code>SpeciesInteractionNetworks.shortestpath</code> \u2014 Function.</p> <pre><code>shortestpath(::Type{BellmanFord}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary,Quantitative}}, source)\n</code></pre> <p>Uses the Bellman-Ford algorithm ...</p> <p>For binary networks, all interactions incur a distance of one. For quantitative networks, an interaction with edge weight w incurs a distance of w\u207b\u00b2, so that strong interactions pull nodes together.</p> <p>source</p>"},{"location":"meta_level/betadiversity/","title":"Beta-diversity","text":""},{"location":"meta_level/betadiversity/#beta-diversity","title":"Beta-diversity","text":"<p>Abstract</p> <p>These methods are used to measure the beta-diversity of two networks, by partitioning variation into the dissimilarity of species (\u03b2S), interactions (\u03b2OS), and whole networks (\u03b2WN).</p> <p></p> <p></p>"},{"location":"meta_level/betadiversity/#components-of-networks-beta-diversity","title":"Components of networks beta diversity","text":"<p># <code>SpeciesInteractionNetworks.BetaDivComponent</code> \u2014 Type.</p> <pre><code>BetaDivComponent\n</code></pre> <p>The <code>betadiversity</code> methods all use a subtype of <code>BetaDivComponent</code> as their first argument, to determine which component should be measured.</p> <p>All of the partitions follow the Koleff et al. (2003) approach, where the beta diversity is measured on the cardinality of sets. Specifically, all <code>betadiversity</code> functions will return a named tuple with three fields, called <code>shared</code>, <code>left</code>, and <code>right</code>. These represent, respectively, the number of items common to both networks, the number of items unique to the first argument, and the number of items unique to the second argument.</p> <p>References</p> <p>Koleff, Gaston and Lennon (2003)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.\u03b2S</code> \u2014 Type.</p> <pre><code>\u03b2S\n</code></pre> <p>The species dissimilarity between two networks is, straightforwardly, the usual \u03b2 diversity applied to the list of nodes. In the case of networks that are not uniparite, we can further calculate this dissimilarity for the different dimensions of the network.</p> <p>References</p> <p>Koleff, Gaston and Lennon (2003)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.\u03b2OS</code> \u2014 Type.</p> <pre><code>\u03b2OS\n</code></pre> <p>The overlapping-species interaction dissimilarity measures the dissimilarity in the interactions between species that are shared between two networks. In other words, interactions are only compared if they involve two interactions that are established between species present in both networks.</p> <p>References</p> <p>Poisot, Canard, Mouillot, Mouquet and Gravel (2012)</p> <p>Canard, Mouquet, Mouillot, Stanko, Miklisova and Gravel (2014)</p> <p>Poisot (2022)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.\u03b2WN</code> \u2014 Type.</p> <pre><code>\u03b2WN\n</code></pre> <p>The whole-network interaction dissimilarity measures the dissimilarity between interactions in all species of either network. It is trivially maximized when the networks have no species in common.</p> <p>References</p> <p>Poisot, Canard, Mouillot, Mouquet and Gravel (2012)</p> <p>Canard, Mouquet, Mouillot, Stanko, Miklisova and Gravel (2014)</p> <p>Poisot (2022)</p> <p>source</p> <p>What about the species turnover component?</p> <p>In Poisot et al. (2012), we introduced the idea that the impact of species turnover can often be expressed as the difference between the whole-network (<code>\u03b2WN</code>) and overlapping-species (<code>\u03b2OS</code>) dissimilarities. This is only true for some measures. Following the arguments laid out in Poisot (2022), we have not added this as a built-in function. If there is a need to measure the impact of turnover, it is recommended to express it as (wn-os)/wn.</p> <p></p> <p></p>"},{"location":"meta_level/betadiversity/#beta-diversity-measures","title":"Beta diversity measures","text":"<p>The <code>betadiversity</code> function will always return a named tuple with three entries, named</p> <p># <code>SpeciesInteractionNetworks.betadiversity</code> \u2014 Function.</p> <pre><code>betadiversity(::Type{\u03b2S},U::T,V::T,dims::Integer = 0,) where {T &lt;: SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}}\n</code></pre> <p>Species-level \u03b2 diversity between networks. By default, this return the species dissimilarity for the entire network. An optional last argument <code>dims</code> can be used, to specify top (<code>1</code>) and bottom (<code>2</code>) levels.</p> <p>source</p> <pre><code>betadiversity(::Type{\u03b2WN},U::T,V::T) where {T &lt;: SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}}\n</code></pre> <p>Network-level \u03b2 diversity between networks. By default, this return the species dissimilarity for the entire network. An optional last argument <code>dims</code> can be used, to specify top (<code>1</code>) and bottom (<code>2</code>) levels.</p> <p>source</p>"},{"location":"meta_level/dissimilarities/","title":"Beta-diversity measures","text":""},{"location":"meta_level/dissimilarities/#list-of-dissimilarity-functions","title":"List of dissimilarity functions","text":"<p>Abstract</p> <p>The methods in this page are from Koleff et al. (2003); when called on the output of <code>betadiversity</code>, they will return a (dis)similarity score.</p> <p>In the original paper (Koleff et al., 2003), the measures are expressed as a function of $a$ (the number of shared elements), $b$ (the number of elements unique to the right/neighbouring set), and $c$ (the number of elements unique to the left/focal set). In this documentation, we use a slightly different convention, where $c = L$ (left), $a = S$ (shared), and $b = R$ (right).</p> <p></p> <p></p>"},{"location":"meta_level/dissimilarities/#list-of-measures","title":"List of measures","text":"<p># <code>SpeciesInteractionNetworks.KGL01</code> \u2014 Function.</p> <pre><code>KGL01(S::T) where {T&lt;:NamedTuple}\n</code></pre> <p>$\\beta_w = \\frac{L+S+R}{(2S + L + R)/2}$</p> <p>References</p> <p>Magurran (1988)</p> <p>Southwood and Henderson (2009)</p> <p>Whittaker (1960)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.KGL02</code> \u2014 Function.</p> <pre><code>KGL02(S::T) where {T&lt;:NamedTuple}\n</code></pre> <p>$\\beta_{-1} = \\frac{L+S+R}{(2S + L + R)/2}-1$</p> <p>References</p> <p>Harrison, Ross and Lawton (1992)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.KGL03</code> \u2014 Function.</p> <pre><code>KGL03(S::T) where {T&lt;:NamedTuple}\n</code></pre> <p>$\\beta_{c} = \\frac{L+R}{2}$</p> <p>References</p> <p>Cody (1975) </p> <p>source</p> <p># <code>SpeciesInteractionNetworks.KGL08</code> \u2014 Function.</p> <pre><code>KGL08(S::T) where {T&lt;:NamedTuple}\n</code></pre> <p>$\\beta_t = \\frac{L+R}{(2S + L + R)}$</p> <p>This method is used in Poisot (2022), and has a lot of desirable properties. We suggest its use as a default.</p> <p>References</p> <p>Wilson and Shmida (1984)</p> <p>source</p>"},{"location":"meta_level/sets/","title":"Set operations","text":""},{"location":"meta_level/sets/#networks-as-sets","title":"Networks as sets","text":"<p>Abstract</p> <p>A number of operations can be applied to networks. This include <code>union</code>, <code>intersect</code>, and <code>setdiff</code>. These are useful when workin on network beta-diversity.</p> <p></p> <p></p>"},{"location":"meta_level/sets/#operations","title":"Operations","text":"<p>&lt;a id='Base.union-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})' href='#Base.union-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})'&gt;# <code>Base.union</code> \u2014 Method.</p> <pre><code>Base.union(U::T, V::T) where {T &lt;: SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}}\n</code></pre> <p>The union of two networks (<code>U \u222a V</code>) is the union of their species and egdes, i.e. everything that is in either networks is present in the union.</p> <p>source</p> <p>&lt;a id='Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})' href='#Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})'&gt;# <code>Base.intersect</code> \u2014 Method.</p> <pre><code>Base.intersect(U::T, V::T) where {T &lt;: SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}}\n</code></pre> <p>The intersect of two networks (<code>U \u2229 V</code>) is the network composed of species in both networks, and the interactions present in both networks as well. Note that species that have no interaction in common between the two networks will still be in the resulting network, but with no interactions.</p> <p>source</p> <p>&lt;a id='Base.setdiff-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})' href='#Base.setdiff-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})'&gt;# <code>Base.setdiff</code> \u2014 Method.</p> <pre><code>Base.setdiff(U::T, V::T) where {T &lt;: SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}}\n</code></pre> <p>The <code>setdiff</code> between two networks is the species and interactions that are unique to the first argument. Note that the operation is not commutative, i.e. <code>setdiff(U,V)\u2260setdiff(V,U)</code>. </p> <p>source</p>"},{"location":"micro_level/centrality/","title":"Centrality","text":""},{"location":"micro_level/centrality/#measures-of-centrality","title":"Measures of centrality","text":"<p>Abstract</p> <p>Centrality can help in quantifying the importance of species in a network. These function will measure the centrality of all species under different algorithms. There is a single wrapper function called <code>centrality</code>, which uses an optional first argument to specify the algorithm to use.</p> <p>The centrality scores are returned so that they sum to one. This is intended to make sure that within a network, the values for different nodes are comparable.</p> <p></p> <p></p>"},{"location":"micro_level/centrality/#implemented-algorithms","title":"Implemented algorithms","text":"<p># <code>SpeciesInteractionNetworks.CentralityMethod</code> \u2014 Type.</p> <pre><code>CentralityMethod\n</code></pre> <p>All algorithms for centrality are subtypes of <code>CentralityMethod</code>. These algorithms do not take additional arguments, which are instead passed to the <code>centrality</code> method.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.KatzCentrality</code> \u2014 Type.</p> <pre><code>KatzCentrality\n</code></pre> <p>This type is used to perform the Katz centrality analysis.</p> <p>References</p> <p>Katz (1953)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.EigenvectorCentrality</code> \u2014 Type.</p> <pre><code>EigenvectorCentrality\n</code></pre> <p>This type is used to perform the Eigenvector centrality analysis.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.ClosenessCentrality</code> \u2014 Type.</p> <pre><code>ClosenessCentrality\n</code></pre> <p>Closeness centrality is defined as the reciprocal of farness, i.e. 1 over the sum of shortest paths from the source node to all other nodes. In the case of probabilistic networks, we use the random walk approximation of closeness centrality, where the distance is defined as first passage time.</p> <p>References</p> <p>Bavelas (1950)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.ResidualClosenessCentrality</code> \u2014 Type.</p> <pre><code>ResidualClosenessCentrality\n</code></pre> <p>References</p> <p>Dangalchev (2006)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.GeneralizedClosenessCentrality</code> \u2014 Type.</p> <pre><code>GeneralizedClosenessCentrality\n</code></pre> <p>References</p> <p>Dangalchev (2011)</p> <p>source</p> <p></p> <p></p>"},{"location":"micro_level/centrality/#centrality-function","title":"Centrality function","text":"<p># <code>SpeciesInteractionNetworks.centrality</code> \u2014 Function.</p> <pre><code>centrality(N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary, Probabilistic}})\n</code></pre> <p>If no type is given as the first argument, the centrality function will use <code>ClosenessCentrality</code>.</p> <p>source</p> <pre><code>centrality(::Type{ClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Probabilistic})\n</code></pre> <p>The closeness centrality of a probabilistic network is measured using the random walk closeness centrality, where the distance between two nodes i and j is measured as the first passage time on node j of a random walk starting on node i. This function does not look for shortest paths, and is therefore reasonably fast.</p> <p>source</p> <pre><code>centrality(::Type{ClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary})\n</code></pre> <p>The closeness centrality of a binary network is the reciprocal of the sum of shortest paths.</p> <p>source</p> <pre><code>centrality(::Type{ResidualClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary})\n</code></pre> <p>The residual closeness centrality of a binary network is the sum of the residuals of two to the power of the length of shortest paths.</p> <p>source</p> <pre><code>centrality(::Type{GeneralizedClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary}; \u03b1=0.1)\n</code></pre> <p>The generalized closeness centrality of a binary network ranges from the degree centrality (\u03b1 is 0) to the number of reachable nodes (\u03b1=1).</p> <p>source</p> <pre><code>centrality(::Type{KatzCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary, Probabilistic}}; \u03b1::AbstractFloat=0.1)\n</code></pre> <p>This measure gives a different weight to every subsequent connection (<code>\u03b1</code>). <code>\u03b1</code> is a weight, specifically the attenuation of each subsequent move away from the node, and therefore must be positive.</p> <p>Note that internally, this function uses linear algebra shortcuts (rather than a sum over path lengths) to calculate the centrality, which is faster. As a consequence, there is, for each network, a maximal value of \u03b1 that is the reciprocal of the absolute value of the leading eigenvalue of the adjacency matrix. This \u03b1 has no analytical solution when the adjacency matrix has complex eigenvalues. It is recommended to use this centrality algorithm as part of a <code>try</code>/<code>catch</code> block if using large values of \u03b1.</p> <p>References</p> <p>Junker and Schreiber (2008)</p> <p>source</p> <pre><code>centrality(::Type{EigenvectorCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Interactions})\n</code></pre> <p>Eigencentrality, corrected so that the centralities in the network sum to one.</p> <p>The eigenvector centrality is calculated using Von Mises iteration, starting from a random vector.</p> <p>where A is the adjacency matrix of the graph, b is the vector of centralities, At each iteration, the vector is updated to be A\u00d7b/|A\u00d7b|, and |\u22c5| is the norm.</p> <p>The number of iterations is determined by the variable <code>SpeciesInteractionNetworks.CENTRALITY_MAXITER</code>, and the algorithm usually converges rapidly.</p> <p>References</p> <p>Landau (1895)</p> <p>source</p>"},{"location":"micro_level/specificity/","title":"Specificity","text":""},{"location":"micro_level/specificity/#specificity","title":"Specificity","text":"<p>Abstract</p> <p>The specificity of species in a network is measured either as a function of the proportion of resouces they effectively use (for binary networks), or as a function of the distribution of their performance on these resources (for quantitative networks). This page also lists functions related to the degree distribution.</p> <p></p> <p></p>"},{"location":"micro_level/specificity/#measures-of-specificity","title":"Measures of specificity","text":"<p>The packages relies on the Paired Difference Index to calculate specificity, as it can be applied to both binary and quantitative data.</p> <p># <code>SpeciesInteractionNetworks.specificity</code> \u2014 Function.</p> <pre><code>specificity(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Union{Binary,Quantitative}})\n</code></pre> <p>For a deterministic network, this function will return a dictionary mapping each top-level species to its specificity. The same index (Paired Differences Index) is used for binary and quantitative networks. A value of one corresponds to maximum specialism, and a value of zero to maximum generalism. The index is symmetrical, so that a species with a value of one half is neither specialist nor generalist.</p> <p>References</p> <p>Poisot, Canard, Mouquet and Hochberg (2012)</p> <p>source</p> <pre><code>specificity(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Union{Binary,Quantitative}}, sp)\n</code></pre> <p>For a deterministic network, this function will return the specificity of species <code>sp</code>.</p> <p>References</p> <p>Poisot, Canard, Mouquet and Hochberg (2012)</p> <p>source</p> <p></p> <p></p>"},{"location":"micro_level/specificity/#degree","title":"Degree","text":"<p># <code>SpeciesInteractionNetworks.degree</code> \u2014 Function.</p> <pre><code>degree(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns the degree, i.e. (expected) number of interactions involving each species. Note that you can specificy a second argument which is a species from the network, giving the degree of this species alone.</p> <p>References</p> <p>Schoener (1989)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.generality</code> \u2014 Function.</p> <pre><code>generality(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns the generality, i.e. (expected) number of interactions established by each species. Note that you can specificy a second argument which is a species from the network, giving the generality of this species alone.</p> <p>References</p> <p>Schoener (1989)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.vulnerability</code> \u2014 Function.</p> <pre><code>vulnerability(N::SpeciesInteractionNetwork)\n</code></pre> <p>Returns the vulnerability, i.e. (expected) number of interactions received by each species. Note that you can specificy a second argument which is a species from the network, giving the vulnerability of this species alone.</p> <p>References</p> <p>Schoener (1989)</p> <p>source</p>"},{"location":"random_networks/permutations/","title":"Permutations","text":""},{"location":"random_networks/permutations/#permutations-of-networks","title":"Permutations of networks","text":"<p>Abstract</p> <p>The methods presented in this page perform network permutation, i.e. they move interactions around while also respecting a number of constraints. Permutations are used in null hypothesis testing, or can be used alongside e.g. simulated annealing to bring networks closer to a specified structure.</p> <p>The functions for permutations are using an edge-swap algorithm, in which the endpoint of interactions is switched to re-wire the network without changing the degree distribution. Each call to the <code>swap!</code> function will modify the network, and perform a single edge swap.</p> <p>Maximum iterations when doing permutations</p> <p>Every permutation will try up to <code>SpeciesInteractionNetworks.SWAP_MAXITER</code> times (defaults to 100) to find a suitable pair of edges to swap, and then return the network unshuffled if they failed to find a suitable pair of edges to swap. This value can be changed.</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-constraints","title":"Permutation constraints","text":"<p>Permutations are constrained, in that we can guarantee that the resulting network may have structural properties that are similar to the original network. The type of constraint we apply is determined by the <code>PermutationConstrant</code> enumerated type.</p> <p># <code>SpeciesInteractionNetworks.PermutationConstraint</code> \u2014 Type.</p> <pre><code>PermutationConstraint\n</code></pre> <p>The <code>PermutationConstraint</code> specifies which structural constraint is enforced. It is defined as an abstract type, and the subtypes can be passed as the second argument to <code>swap!</code>.</p> <p>Currently supported constraints are <code>Degree</code> (degree distribution is maintained), <code>Generality</code> (number of out-going links is maintained), <code>Vulnerability</code> (number of in-going links is maintained), and <code>Connectance</code> (only the connectance is maintained). Note that in addition, species cannot become disconnected, even if the constraint is not acting on the degree / degree distribution.</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-of-a-network","title":"Permutation of a network","text":"<p>Note that the permutations are currently limited to networks with <code>Binary</code> interactions.</p> <p># <code>SpeciesInteractionNetworks.swap!</code> \u2014 Function.</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Performs one swap of interactions in the network. If no <code>PermutationConstraint</code> is given as a second argument, the degree distribution of all species will be maintained.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Degree})\n</code></pre> <p>Permutations with a constraint by degree work by picking two interacting species pairs, (r1, s1) and (r2, s2), and trying to replace them by (r1, s2) and (r2, s1).</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Generality})\n</code></pre> <p>Permutations with a constraint by degree work by picking one interacting species pair, (r1, s1), and a new stem species s3, trying to replace them by (r1, s3). This function only applies if the result of this permutations does not remove the last incoming link from s1.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Connectance})\n</code></pre> <p>Permutations with a constraint by connectance will randomly (and with equal probability) perform a move that is constrained by degree, generality, or vulnerability.</p> <p>source</p>"},{"location":"random_networks/randomdraws/","title":"Random draws","text":""},{"location":"random_networks/randomdraws/#random-draws","title":"Random draws","text":"<p>Abstract</p> <p>This page presents an overview of methods to draw from a probabilistic network, and ways to generate structural null models from a binary network under various constraints.</p> <p></p> <p></p>"},{"location":"random_networks/randomdraws/#drawing-from-a-probabilistic-network","title":"Drawing from a probabilistic network","text":"<p># <code>SpeciesInteractionNetworks.randomdraws</code> \u2014 Function.</p> <pre><code>randomdraws(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Probabilistic})\n</code></pre> <p>Returns a binary network by making random draws from a probabilistic network. Each interaction is considered as an independent Bernoulli trial.</p> <p>References</p> <p>Poisot, Cirtwill, Cazelles, Gravel, Fortin and Stouffer (2015)</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/randomdraws/#null-models-for-hypothesis-testing","title":"Null models for hypothesis testing","text":"<p>The usual null models of network structure can be generated using a <code>PermutationConstraint</code> as the first argument. Although technically speaking, these are not permutations, it is nevertheless useful to map the constraints from one method of network generation to another.</p> <p># <code>SpeciesInteractionNetworks.nullmodel</code> \u2014 Function.</p> <pre><code>nullmodel(::Type{Degree}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Returns a probabilistic network under the null model that all interactions occurr with a probability equal to the average of their generality and vulnerability, i.e. proportionally to how many links the species involved are establishing:</p> <p>$P(i \\rightarrow j) = \\frac{1}{2}\\left(\\frac{\\sum A_{i \\rightarrow \\cdot}}{|B|} + \\frac{\\sum A_{\\cdot \\rightarrow j}}{|T|} \\right)$</p> <p>References</p> <p>Bascompte, Jordano, Meli\u00e1n and Olesen (2003)</p> <p>source</p> <pre><code>nullmodel(::Type{Connectance}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Returns a probabilistic network under the null model that all interactions occurr with a probability equal to the network connectance, i.e. in a network with $L$ links, and $|T|$ species on the top and $|B|$ species on the bottom,</p> <p>$P(i \\rightarrow j) = \\frac{L}{|T|\\times |B|}$</p> <p>Note that for <code>Unipartite</code> networks, $|T| = |B| = |S|$ (the two sides have the same number of species).</p> <p>References</p> <p>Fortuna and Bascompte (2006)</p> <p>source</p> <pre><code>nullmodel(::Type{Generality}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Returns a probabilistic network under the null model that interactions happen proportionally to the generality of the species, i.e. their expected number of outgoing links:</p> <p>$P(i \\rightarrow j) = \\frac{\\sum A_{i \\rightarrow \\cdot}}{|B|}$</p> <p>References</p> <p>Poisot, Stanko, Miklisov{\u00e1} and Morand (2013)</p> <p>Weitz, Poisot, Meyer, Flores, Valverde, Sullivan and Hochberg (2013)</p> <p>source</p> <pre><code>nullmodel(::Type{Generality}, N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Returns a probabilistic network under the null model that interactions happen proportionally to the vulnerability of the species, i.e. their expected number of incomin links:</p> <p>$P(i \\rightarrow j) = \\frac{\\sum A_{\\cdot \\rightarrow j}}{|T|}$</p> <p>References</p> <p>Poisot, Stanko, Miklisov{\u00e1} and Morand (2013)</p> <p>Weitz, Poisot, Meyer, Flores, Valverde, Sullivan and Hochberg (2013)</p> <p>source</p> <pre><code>nullmodel(::Type{C}, N::SpeciesInteractionNetwork{&lt;:Partiteness{T}, &lt;:Binary}, sp::T) where {C &lt;: PermutationConstraint, T}\n</code></pre> <p>Returns a probabilistic network where the interaction probabilites for species <code>sp</code> have been replaced by the probabilities given under the null model specified by the permutation constraint given as its first argument; see <code>nullmodel</code>. All interactions that do not involve species <code>sp</code> have their probability set to 1.</p> <p>The original publication (Saavedra et al., 2011) uses [<code>Degree</code>] as the permutation constraint, but this function has been written to be more general.</p> <p>This network can be passed to <code>speciescontribution</code>.</p> <p>References</p> <p>Saavedra, Stouffer, Uzzi and Bascompte (2011)</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/randomdraws/#species-level-contributions-based-on-null-models","title":"Species-level contributions based on null models","text":"<p>The null model approach can be extended to the contribution of each species. We offer a generic interface to generating pseudo-random networks where the target species has its interactions randomized, while all other interactions remain fixed.</p> <p># <code>SpeciesInteractionNetworks.speciescontribution</code> \u2014 Function.</p> <pre><code>speciescontribution(::Type{C}, N::SpeciesInteractionNetwork{&lt;:Partiteness{T}, &lt;:Binary}, sp::T, f, args...; replicates=999, kwargs...) where {C &lt;: PermutationConstraint, T}\n</code></pre> <p>Returns the contribution of species <code>sp</code> to the value of <code>f(N, args...; kwargs...)</code>, after Saavedra et al. (2011). Specifically, this function will generate a species-specific <code>nullmodel</code>, and then update in-place a copy of the network where interactions of species <code>sp</code> are randomly re-drawn according to the probabilities under the null model.</p> <p>Note that for the sake of generality, the function <code>f</code> can accept both positional and keyword arguments.</p> <p>The contribution of a species to the score is defined as</p> <p>$\\frac{f(N)-\\mu_f}{\\sigma_f}$</p> <p>where \u03bc and \u03c3 are respectively the average and standard deviation of the values of the measure <code>f</code> on the randomized networks.</p> <p>In order to ensure that the networks generated under the null model are informative, we constrain the number of interactions of <code>sp</code> in the randomized network to be equal to the number of interactions of <code>sp</code> in the original network.</p> <p>References</p> <p>Saavedra, Stouffer, Uzzi and Bascompte (2011)</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/randomdraws/#linear-filtering","title":"Linear filtering","text":"<p>The linear filter from Stock et al. (2017) is a general formulation of the null models presented above.</p> <p># <code>SpeciesInteractionNetworks.linearfilter</code> \u2014 Function.</p> <pre><code>linearfilter(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}; \u03b1::Vector{T}=ones(4)) where {T &lt;: AbstractFloat}\n</code></pre> <p>The linear filter returns a probability of observing an interaction as a function of a linear combination of the observed value of the interaction, the generality and vulnerability of the species, and the connectance of the network. It is also used to provide a generic implementation of <code>nullmodel</code>.</p> <p>Specifically, the probability of an interaction is expressed as a weighted average, the weights being given as the vector <code>\u03b1</code>.</p> <p>The vector <code>\u03b1</code> has four elements, all positive, and $\\sum \\alpha = 1$ (this is enforced internally, and does not need to be checked by the user).</p> <p>$\\alpha_1$ is the weight of the original interaction; it helps to think of it as a penalization parameter, that explains how important the original observation is.</p> <p>$\\alpha_2$ is the weight of generality; it regulates how important the probability of the species establishing an interaction is in the resulting network.</p> <p>$\\alpha_3$ is the weight of vulnerability; it regulates how important the probability of the species receing an interaction is in the resulting network.</p> <p>$\\alpha_4$ is the weight of connectance.</p> <p>References</p> <p>Stock, Poisot, Waegeman and Baets (2017)</p> <p>source</p>"},{"location":"random_networks/structural/","title":"Structural models","text":""},{"location":"random_networks/structural/#structural-models","title":"Structural models","text":"<p>Abstract</p> <p>These functions generate random networks based on structural models. The models are given as types (specifically subtypes of <code>StructuralModel</code>), and return a network the type of which depends on the generative algorithm, when passed to the <code>structuralmodel</code> function.</p> <p></p> <p></p>"},{"location":"random_networks/structural/#models","title":"Models","text":"<p># <code>SpeciesInteractionNetworks.StructuralModel</code> \u2014 Type.</p> <pre><code>StructuralModel\n</code></pre> <p>...</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.NicheModel</code> \u2014 Type.</p> <pre><code>NicheModel\n</code></pre> <p>The niche model of food webs is one of the most emblematic food web models. Based on a given species richness and expected connectance, it generates food webs with properties that closely reproduce empirical networks. One particular property of the food webs generated with this model is that they are interval, which is to say that there are not gaps in the diet of species.</p> <p>References</p> <p>Williams and Martinez (2000)</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/structural/#the-generative-function","title":"The generative function","text":"<p># <code>SpeciesInteractionNetworks.structuralmodel</code> \u2014 Function.</p> <pre><code>structuralmodel(::Type{NicheModel}, species::Integer=10, connectance::AbstractFloat=0.2)\n</code></pre> <p>Generate a food web under the niche model with the given number of species, and an expected connectance. Note that by the nature of the niche model algorithm, only the species richness is guaranteed; there is no guarantee that the connectance will be correct.</p> <p>See <code>NicheModel</code> for more information about the niche model.</p> <p>source</p>"},{"location":"use_cases/centrality/","title":"Species centrality","text":""},{"location":"use_cases/centrality/#measuring-centrality","title":"Measuring centrality","text":"<p>Centrality</p> <p>In this example, we will...</p> <pre><code>using SpeciesInteractionNetworks\n\nnodes = Unipartite([:Wyeomyia, :Metriocnemus, :Fletcherimyia, :Habrotrocha, :Protozoa, :Sarraceniopus, :Bacteria, :Insects])\nedges = Binary(zeros(Bool, (richness(nodes), richness(nodes))))\nN = SpeciesInteractionNetwork(nodes, edges)\n\nN[:Metriocnemus, :Insects] = true\nN[:Fletcherimyia, :Insects] = true\nN[:Bacteria, :Insects] = true\nN[:Sarraceniopus, :Bacteria] = true\nN[:Habrotrocha, :Bacteria] = true\nN[:Protozoa, :Bacteria] = true\nN[:Protozoa, :Habrotrocha] = true\nN[:Wyeomyia, :Habrotrocha] = true\nN[:Wyeomyia, :Protozoa] = true\nN[:Wyeomyia, :Bacteria] = true\n\ninteractions(N)\n</code></pre> <pre><code>10-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:Wyeomyia, :Habrotrocha, 1)\n (:Wyeomyia, :Protozoa, 1)\n (:Wyeomyia, :Bacteria, 1)\n (:Metriocnemus, :Insects, 1)\n (:Fletcherimyia, :Insects, 1)\n (:Habrotrocha, :Bacteria, 1)\n (:Protozoa, :Habrotrocha, 1)\n (:Protozoa, :Bacteria, 1)\n (:Sarraceniopus, :Bacteria, 1)\n (:Bacteria, :Insects, 1)\n</code></pre> <p>Change \u03b1</p> <pre><code>attenuation = 10.0.^LinRange(-1, 0, 20)\nc_insect = zeros(length(attenuation))\nc_bacteria = zeros(length(attenuation))\nc_protozoa = zeros(length(attenuation))\nfor (i,\u03b1) in enumerate(attenuation)\nci = centrality(KatzCentrality, N; \u03b1=\u03b1)\nc_insect[i] = ci[:Insects]\nc_bacteria[i] = ci[:Bacteria]\nc_protozoa[i] = ci[:Protozoa]\nend\n</code></pre> <p>Make a plot</p> <pre><code>import CairoMakie\n\nf = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Attenuation\", ylabel = \"Centrality\", xscale=log10)\nCairoMakie.lines!(ax, attenuation, c_insect, color=(:black, 0.5), label=\"Insect\")\nCairoMakie.lines!(ax, attenuation, c_bacteria, color=(:green, 0.5), label=\"Bacteria\")\nCairoMakie.lines!(ax, attenuation, c_protozoa, color=(:orange, 0.5), label=\"Protozoa\")\nCairoMakie.tightlimits!(ax)\nCairoMakie.axislegend(position=:lb)\nCairoMakie.current_figure()\n</code></pre> <p></p> <p>same with closeness centrality</p> <pre><code>attenuation = 10.0.^LinRange(-1, 0, 20)\nc_insect = zeros(length(attenuation))\nc_bacteria = zeros(length(attenuation))\nc_protozoa = zeros(length(attenuation))\nfor (i,\u03b1) in enumerate(attenuation)\nci = centrality(GeneralizedClosenessCentrality, N; \u03b1=\u03b1)\nc_insect[i] = ci[:Insects]\nc_bacteria[i] = ci[:Bacteria]\nc_protozoa[i] = ci[:Protozoa]\nend\n</code></pre> <p>Make a plot</p> <pre><code>import CairoMakie\n\nf = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Attenuation\", ylabel = \"Centrality\", xscale=log10)\nCairoMakie.lines!(ax, attenuation, c_insect, color=(:black, 0.5), label=\"Insect\")\nCairoMakie.lines!(ax, attenuation, c_bacteria, color=(:green, 0.5), label=\"Bacteria\")\nCairoMakie.lines!(ax, attenuation, c_protozoa, color=(:orange, 0.5), label=\"Protozoa\")\nCairoMakie.tightlimits!(ax)\nCairoMakie.axislegend(position=:lb)\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"use_cases/nichemodel/","title":"Niche model of food webs","text":""},{"location":"use_cases/nichemodel/#spectral-radius-of-the-niche-model","title":"Spectral radius of the niche model","text":"<p>The niche model of food webs</p> <p>In this example, we will...</p> <pre><code>using SpeciesInteractionNetworks\nimport CairoMakie\n</code></pre> <p>We can generate a number of random networks:</p> <pre><code>R = [structuralmodel(NicheModel, 25, rand()*0.5) for _ in 1:999]\n</code></pre> <pre><code>999-element Vector{SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}}:\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 5, 6, 7, 8, 12, 2, 3  \u2026  23, 24, 25, 18, 20, 21, 22, 23, 24, 25], [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([3, 4, 4, 5, 6, 9, 5, 6, 7, 8  \u2026  21, 22, 23, 25, 19, 20, 21, 22, 23, 25], [2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 6, 7, 15, 16, 3, 4, 5, 6  \u2026  18, 22, 23, 25, 18, 23, 25, 18, 23, 25], [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 5, 7, 13, 3, 4, 5, 7  \u2026  22, 25, 20, 22, 25, 20, 22, 25, 25, 25], [2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 5, 7, 9, 10, 13, 16, 2  \u2026  22, 23, 24, 25, 20, 21, 22, 23, 24, 25], [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 5, 6, 7, 9, 13, 21, 22  \u2026  23, 25, 18, 20, 23, 25, 18, 20, 23, 25], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 10, 17, 2, 4, 5, 10, 17  \u2026  21, 23, 24, 19, 21, 23, 24, 21, 23, 24], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 5, 7, 8, 3, 4, 5, 8, 9  \u2026  21, 22, 24, 21, 22, 24, 22, 24, 22, 24], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([3, 20, 20, 20, 5, 6, 14, 15, 16, 17  \u2026  24, 25, 22, 24, 25, 22, 24, 25, 22, 25], [1, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([3, 4, 10, 11, 15, 3, 4, 10, 11, 15  \u2026  23, 24, 25, 20, 23, 24, 20, 24, 20, 24], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n \u22ee\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([3, 4, 5, 25, 3, 5, 6, 7, 8, 17  \u2026  23, 24, 12, 15, 18, 20, 21, 22, 23, 24], [1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 6, 14, 19, 2, 5, 14, 19, 20  \u2026  24, 13, 17, 24, 17, 24, 24, 21, 24, 24], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 18], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 13, 3, 9, 13, 15, 3, 5, 8  \u2026  24, 16, 18, 22, 24, 16, 18, 24, 24, 24], [1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 22, 23], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 6, 21, 23, 3, 4, 5, 7, 10, 13  \u2026  23, 25, 19, 22, 25, 19, 22, 25, 19, 25], [1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 4, 9, 12, 21, 22, 2, 3, 4, 5  \u2026  23, 24, 23, 24, 23, 24, 23, 24, 23, 24], [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([3, 7, 2, 3, 4, 5, 7, 4, 5, 7  \u2026  18, 21, 22, 24, 25, 18, 21, 22, 24, 25], [1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 3, 4, 6, 7, 2, 4, 6, 7, 24  \u2026  22, 20, 21, 22, 20, 21, 22, 20, 21, 22], [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([23, 8, 16, 8, 17, 21, 15, 21, 18, 18, 22, 22, 24], [1, 2, 2, 3, 4, 11, 12, 12, 13, 14, 20, 21, 22], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:node_1, :node_2, :node_3, :node_4, :node_5, :node_6, :node_7, :node_8, :node_9, :node_10  \u2026  :node_16, :node_17, :node_18, :node_19, :node_20, :node_21, :node_22, :node_23, :node_24, :node_25]), Binary{Bool}(sparse([2, 4, 8, 12, 14, 16, 22, 2, 3, 4  \u2026  24, 25, 20, 23, 24, 25, 20, 23, 24, 25], [1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 25, 25)))\n</code></pre> <p>We can get the connectance of the random networks \u2013 recall that the niche model is not going to strictly respect the target connectance:</p> <pre><code>co = connectance.(R)\n</code></pre> <pre><code>999-element Vector{Float64}:\n 0.4288\n 0.2768\n 0.2992\n 0.2528\n 0.4592\n 0.3824\n 0.3376\n 0.2592\n 0.1344\n 0.3136\n \u22ee\n 0.3584\n 0.128\n 0.1968\n 0.3616\n 0.28\n 0.2944\n 0.3104\n 0.0208\n 0.3856\n</code></pre> <p>Finally, we can look at the expected relationship between connectance and spectral radius:</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Connectance\", ylabel=\"Spectral radius\")\nCairoMakie.scatter!(ax, co, spectralradius.(R), color=(:slategray,0.4))\nCairoMakie.tightlimits!(ax)\nCairoMakie.xlims!(ax, (0.0, 0.5))\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"use_cases/nullmodels/","title":"Significance testing","text":""},{"location":"use_cases/nullmodels/#null-models","title":"Null models","text":"<p>In order to illustrate the use of null models, we will look at the data from Dupont et al. (2003), and specifically generate multiple networks under different null models, then compare the nestedness (using <code>\u03b7</code>) to the empirical network. We will then use the approach of Saavedra et al. (2011) to quantify the contribution of each species to nestedness.</p> <pre><code>using SpeciesInteractionNetworks\nimport CairoMakie\nimport Statistics\n</code></pre> <p>The data are available from the IWDB, but in order to avoid making unecessary calls to their webserver, we have reproduced a version here:</p> <pre><code>int_mat = Bool[\n1 1 1 0 1 1 0 0 1 0 0; 1 0 0 1 1 1 0 1 0 1 0; 1 0 1 0 1 1 1 0 0 0 0;\n0 1 0 1 0 1 1 1 0 1 0; 1 0 1 0 1 1 1 0 0 1 0; 0 1 1 0 1 0 1 0 1 0 1;\n1 1 1 1 0 0 1 0 0 0 0; 1 0 0 0 1 1 0 0 0 1 0; 1 1 1 0 0 0 0 1 0 0 0;\n1 1 0 0 0 1 1 0 0 0 0; 1 1 0 1 0 0 0 0 1 0 0; 1 1 1 0 0 0 0 1 0 0 0;\n0 1 0 1 0 0 0 1 0 0 0; 1 0 1 0 1 0 0 0 0 0 0; 0 0 1 0 1 0 0 0 0 0 1;\n1 0 1 1 0 0 0 0 0 0 0; 0 0 1 1 1 0 0 0 0 0 0; 0 1 0 0 0 0 1 0 1 0 0;\n0 0 0 0 0 1 1 0 0 0 0; 0 0 0 1 0 1 0 0 0 0 0; 1 0 0 0 1 0 0 0 0 0 0;\n0 0 1 0 0 0 0 1 0 0 0; 1 0 0 0 0 0 0 0 1 0 0; 0 0 1 0 0 0 0 0 1 0 0;\n0 0 0 1 0 0 0 0 0 0 0; 0 1 1 0 0 0 0 0 0 0 0; 1 0 0 1 0 0 0 0 0 0 0;\n1 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 1 0; 0 0 0 0 0 0 0 1 0 0 0;\n0 1 0 0 0 0 0 0 0 0 0; 0 1 0 0 0 0 0 0 0 0 0; 1 0 0 0 0 0 0 0 0 0 0;\n1 0 0 0 0 0 0 0 0 0 0; 0 0 0 1 0 0 0 0 0 0 0; 0 0 0 1 0 0 0 0 0 0 0;\n0 1 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 1 0 0\n]\n</code></pre> <pre><code>38\u00d711 Matrix{Bool}:\n 1  1  1  0  1  1  0  0  1  0  0\n 1  0  0  1  1  1  0  1  0  1  0\n 1  0  1  0  1  1  1  0  0  0  0\n 0  1  0  1  0  1  1  1  0  1  0\n 1  0  1  0  1  1  1  0  0  1  0\n 0  1  1  0  1  0  1  0  1  0  1\n 1  1  1  1  0  0  1  0  0  0  0\n 1  0  0  0  1  1  0  0  0  1  0\n 1  1  1  0  0  0  0  1  0  0  0\n 1  1  0  0  0  1  1  0  0  0  0\n \u22ee              \u22ee              \u22ee\n 0  0  0  0  0  0  0  1  0  0  0\n 0  1  0  0  0  0  0  0  0  0  0\n 0  1  0  0  0  0  0  0  0  0  0\n 1  0  0  0  0  0  0  0  0  0  0\n 1  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0\n 0  1  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  1  0  0\n</code></pre> <p>We can turn this into a network (without species names!):</p> <pre><code>edges = Binary(int_mat)\nnodes = Bipartite(edges)\n\nN = SpeciesInteractionNetwork(nodes, edges)\n@info \"$(richness(N,1)) pollinators\"\n@info \"$(richness(N,2)) plants\"\n@info \"$(length(N)) interactions\"\n</code></pre> <pre><code>[ Info: 38 pollinators\n[ Info: 11 plants\n[ Info: 106 interactions\n</code></pre> <p>We first measure the nestedness of the network:</p> <pre><code>n0 = \u03b7(N)\n</code></pre> <pre><code>0.41842877034736853\n</code></pre> <p>The next step is to generate a template probabilistic network under a specific null model. Here, we will focus on the null model based on the joint degree distribution, as used by e.g. Bascompte et al. (2003).</p> <pre><code>Nd = nullmodel(Degree, N)\n</code></pre> <pre><code>A probabilistic bipartite network\n \u2192 106.0 \u00b1 75.18181818181819 interactions\n \u2192 38 &amp; 11 species\n</code></pre> <p>We can draw samples from this network, and measure their nestedness. But because the random networks might have species that are disconnected. In order to get a sense of the importance of these networks, we will use the <code>isdegenerate</code> function to identify them:</p> <pre><code>Rd = [randomdraws(Nd) for _ in 1:5000]\nconnected_networks = findall(!isdegenerate, Rd)\nnd = \u03b7.(Rd)\n@info round.((minimum(nd), Statistics.median(nd), maximum(nd)); digits=4)\n</code></pre> <pre><code>[ Info: (0.2491, 0.3702, 0.4968)\n</code></pre> <p>Alternative solution</p> <p>An alternative to using <code>filter</code> and <code>isdegenerate</code> is to call the <code>simplify</code> function, which will return a network in which non-interacting species are removed. That being said, simplifying the network changes its richness. This might result in comparing apples and oranges, and seems like a more risky solution.</p> <p>This is all we need to plot the results:</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Nestedness\", ylabel=\"Probability\")\nCairoMakie.hist!(ax, nd; normalization=:probability, fillto=0.0, color=(:slategray, 0.4), bins=20)\nCairoMakie.hist!(ax, nd[connected_networks]; normalization=:probability, fillto=0.0, color=(:orange, 0.4), bins=20)\nCairoMakie.vlines!(ax, [n0], color=:black, linestyle=:dash)\nCairoMakie.tightlimits!(ax)\nCairoMakie.ylims!(ax, (0.0, 0.2))\nCairoMakie.current_figure()\n</code></pre> <p></p> <p>In practice, we are often interested in deriving a p-value from the comparison of the empirical and null values of the structure measure. Note that, functionally, the generation of null models can be seen as permutation testing, and therefore we can approximate the p-value corresponding to the hypothesis that the network is more nested than expected under its degree distribution by looking at the proportion of randomized values that are larger than the empirical observation:</p> <pre><code>@info \"\ud835\udc5d \u2248 $(round(Statistics.mean(n0 .&lt;= nd); digits=3))\"\n</code></pre> <pre><code>[ Info: \ud835\udc5d \u2248 0.095\n</code></pre> <p>We can then compare the result when only looking at networks without disconnected species:</p> <pre><code>@info \"\ud835\udc5d \u2248 $(round(Statistics.mean(n0 .&lt;= nd[connected_networks]); digits=3))\"\n</code></pre> <pre><code>[ Info: \ud835\udc5d \u2248 0.07\n</code></pre> <p>At this time, we can think about the contribution of each species to the global nestedness score. To do this, we will use the approach of Saavedra et al. (2011), in which the contribution of each species is assessed by randomizing only the interactions of this species.</p> <p>The result will be returned as a z-score, where positive values indicate that the species contributes positively to nestedness, a value of zero indicates no effect, and negative values means that the species decreases nestedness.</p> <pre><code>speciescontribution(Degree, N, first(species(N)), \u03b7; replicates=99)\n</code></pre> <pre><code>1.3389303733923614\n</code></pre> <p>We can also iterate over the two levels in the network:</p> <pre><code>contrib_top = [speciescontribution(Degree, N, sp, \u03b7; replicates=99) for sp in species(N, 1)];\ncontrib_bot = [speciescontribution(Degree, N, sp, \u03b7; replicates=99) for sp in species(N, 2)];\n</code></pre> <p>And we can plot the results</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Contribution to nestedness\", ylabel=\"Probability\")\nCairoMakie.hist!(ax, contrib_bot; normalization=:probability, fillto=0.0, color=(:purple, 0.4))\nCairoMakie.hist!(ax, contrib_top; normalization=:probability, fillto=0.0, color=(:green, 0.4))\nCairoMakie.vlines!(ax, [0.0], color=:black, linestyle=:dash)\nCairoMakie.tightlimits!(ax)\nCairoMakie.ylims!(ax, (0.0, 0.4))\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"use_cases/permutations/","title":"Network permutations","text":""},{"location":"use_cases/permutations/#permutations","title":"Permutations","text":"<p>To showcase <code>swap!</code> in practice, we will work through through a simple example of (i) generating a perfectly nested network, (ii) shuffling interactions by maintaining the generality of top-level species, and (iii) looking at the way the nestdeness of the entire network changes with each successive swap.</p> <pre><code>using SpeciesInteractionNetworks\nimport CairoMakie\n</code></pre> <p>We can generate a nested network rather easily, by creating a matrix of binary interactions, where the species interact with species from a lower rank:</p> <pre><code>A = zeros(Bool, (10, 14))\nfor i in axes(A, 1)\nfor j in axes(A, 2)\nif i &lt;= j\nA[i,j] = true\nend\nend\nend\n</code></pre> <p>We can declare a network without having to define all of the species, by first wrapping our matrix inside a <code>Binary</code> type, and then generating a <code>Bipartite</code> species set with the right number of species:</p> <pre><code>edges = Binary(A)\nnodes = Bipartite(edges)\nN = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>A binary bipartite network\n \u2192 95 interactions\n \u2192 10 &amp; 14 species\n</code></pre> <p>The initial nestedness of this network, measured using \u03b7 is (network, top-level contribution, bottom-level contribution):</p> <pre><code>(\u03b7(N), \u03b7(N,1), \u03b7(N,2))\n</code></pre> <pre><code>(1.0, 1.0, 1.0)\n</code></pre> <p>In order to generate the series of successive permutations, we will define an empty array of values, and then for each successive step, calculate the nestedness of the network, and then swap interactions under the given constraint.</p> <pre><code>nestedness_series = zeros(Float64, 1000)\nfor i in axes(nestedness_series, 1)\nnestedness_series[i] = \u03b7(N)\nswap!(N, Generality)\nend\n\n#!!! warning \"A note about swaps and underlying nodes/edges\"\n</code></pre> <p>When we perform the <code>swap!</code> operation, we are modifying the network (this is    what we want!), but we are also modifying the <code>edges</code> object. If you want to    re-use the edges in another network, be mindful of the fact that this will    be the randomized edges. See <code>copy</code> for a way to create new copies of a network.</p> <p>Finally, we can plot the result, to check that 1000 swaps are enough to bring us to some sort of equilibrium of the randomized nestedness:</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Swap\", ylabel = \"Nestedness\")\nCairoMakie.lines!(ax, nestedness_series, color=(:black, 0.5))\nCairoMakie.tightlimits!(ax)\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"use_cases/specificity/","title":"Species specificity","text":""},{"location":"use_cases/specificity/#measuring-spcificity","title":"Measuring spcificity","text":"<p>Measuring specificity</p> <p>In this example, we will...</p> <p>We can generate an example network with three different degrees of specificity:</p> <pre><code>using SpeciesInteractionNetworks\n\nnodes = Bipartite([:A, :B, :C, :D, :E], [:a, :b, :c, :d, :e, :f])\nedges = Quantitative([1 0 0 0 0; 2 0 0 0 0; 1 1 1 0 0; 4 3 2 1 0; 4 4 4 3 0])\nN = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>A quantitative bipartite network\n \u2192 13 interactions\n \u2192 5 &amp; 6 species\n</code></pre> <p>We can calculate the specificity of the top-level species:</p> <pre><code>spe_scores = specificity(N)\n</code></pre> <pre><code>Dict{Symbol, Float64} with 5 entries:\n  :A =&gt; 1.0\n  :D =&gt; 0.625\n  :B =&gt; 1.0\n  :E =&gt; 0.3125\n  :C =&gt; 0.5\n</code></pre> <p>The output of specificity is a dictionary, where the <code>species(N, 1)</code> are keys, and the score for each of these species are the values. We can, for example, look at the specificity for species <code>:D</code>:</p> <pre><code>spe_scores[:D]\n</code></pre> <pre><code>0.625\n</code></pre> <p>Making sense of the score</p> <p>The Paired Differences Index will always return values in the unit interval, and these values are independent from one species to the next. In the example above, species <code>:A</code> and <code>:B</code> have the same (maximum) specificity because they use a single resource. The purpose of the Paired Differences Index is to express specificity in a way that is not affected by the total interaction strenght of the species, because what is well understood can be measured without confounders.</p> <p>As always, keep in mind that the ordering of keys in the dictionary is not fixed. Therefore, it is probably safer to iterate over the <code>species(N, 1)</code> when looking for specific values.</p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#species-interaction-networks","title":"Species Interaction Networks","text":"<p>The <code>SpeciesInteractionNetworks</code> package enables analyses of species interaction networks in Julia. It is a re-master (director's cut?) of <code>EcologicalNetworks</code>.</p> <p>Why a new package?</p> <p>Code rot, experience, and truth in advertising. <code>EcologicalNetworks</code> was initially written in the days of Julia 0.5, and never really caught up with changes in the language (or with accumulated experience in writing code that is easy to maintain). After realizing the the former's type system was often preventing elegant dispatch and was due for a re-write, it made sense to initiate a susbtantial refactor. Additionally, there are ecological networks that do not describe species interactions, which were not covered by the package.</p> <p>The package is built around a type system for species interaction networks, which is intended to capture the different types of data and communities ecologists need to handle. This makes the package extensible, both by writing additional methods with a very fine-tuned dispatch, or by adding additional types that should work out of the box (or be very close to).</p> <p>This package is a library for the analysis of ecological networks. On purpose, we do not provide \"wrapper\"-type functions that would perform an entire analysis. We experimented with this idea during development, and rapidly realized that even for the most simple research project, we needed to make small tweaks that made the wrappers a nuisance. We decided to give you the parts, and it's your job to build the kick-ass spaceship.</p> <p>The measures in the documentation are organized by level of organisation, following the convention of micro (species-level), meso (involving more than one species), macro (network level) and meta (involving mutliple networks).</p>"},{"location":"bibliography/","title":"Bibliography","text":""},{"location":"bibliography/#bibliography","title":"Bibliography","text":"Junker2008Analysis , Analysis of Biological Networks, Wiley, 2008. Bastolla2009architecture Ugo Bastolla, Miguel A. Fortuna, Alberto Pascual-Garc\u00eda, Antonio Ferrera, Bartolo Luque, Jordi Bascompte, The architecture of mutualistic networks minimizes competition and increases biodiversity, Nature, 458(7241), 1018\u20131020, 2009. Bavelas1950Communication Alex Bavelas, Communication Patterns in Task\u2010Oriented Groups, The Journal of the Acoustical Society of America, 22, 725-730, 1950. Dangalchev2006Residual Chavdar Dangalchev, Residual closeness in networks, Physica A, 365, 556-564, 2006. Dangalchev2011Residual Chavdar Dangalchev, Residual Closeness and Generalized Closeness, International Journal of Foundations of Computer Science, 22, 1939-1948, 2011. Katz1953new Leo Katz, A new status index derived from sociometric analysis, Psychometrika, 18, 39-43, 1953. Landau1895Zur Edmund Landau, Zur relativen Wertbemessung der Turnierresultate, Deutsches Wochenschach, 11, 366\u2013369, 1895. Poisot2012comparative Timoth\u00e9e Poisot, Elsa Canard, Nicolas Mouquet, Michael E. Hochberg, A comparative study of ecological specialization estimators, Methods in Ecology &amp; Evolution, 3, 537-544, 2012."},{"location":"internals/","title":"Internals","text":""},{"location":"internals/#internals","title":"Internals","text":""},{"location":"internals/#network-dimensions","title":"Network dimensions","text":""},{"location":"internals/#copy-of-network-data","title":"Copy of network data","text":"<p># <code>Base.copy</code> \u2014 Method.</p> <pre><code>Base.copy(N::SpeciesInteractionNetwork)\n</code></pre> <p>A copy of a network is created by wrapping together a copy of the nodes and a copy of the edges.</p> <p>source</p>"},{"location":"community_level/nestedness/","title":"Nestedness","text":""},{"location":"community_level/nestedness/#nestedness","title":"Nestedness","text":"<p>Abstract</p> <p>The methods presented in this page measure the nestedness of a network. Nestedness is usually restricted to biparite networks.</p> <p></p> <p></p>"},{"location":"community_level/nestedness/#_1","title":"\u03b7","text":"<p>Degree distribution and \u03b7</p> <p>The \u03b7 measure of nestedness is invariant for a given degree distribution. In other words, two networks with the same (joint) degree distribution will always have the same value of \u03b7. As a result, network permutations using <code>swap!</code> and a constraint on the degree will not generate an appropriate null sample. This is also true when only one side on the degree distribution is maintained, for the measure of nestedness on this side.</p> <p># <code>SpeciesInteractionNetworks.\u03b7</code> \u2014 Function.</p> <pre><code>\u03b7(N::SpeciesInteractionNetwork{&lt;:Bipartite, &lt;:Union{Binary, Probabilistic}}, dims::Integer = 0)\n</code></pre> <p>The \u03b7 measure of nestedness is a variation of NODF, it can be calculated at the scale of the entire network (using <code>0</code> as the second argument, which is the default), or for either side of the network (<code>1</code> for rows, <code>2</code> for columns).</p> <p>The measure for the entire network is the average of the nestedness of rows and columns.</p> <p>References</p> <p>Ugo Bastolla, Miguel A. Fortuna, Alberto Pascual-Garc\u00eda, Antonio Ferrera, Bartolo Luque, Jordi Bascompte (2009)</p> <p>source</p> <p></p> <p></p>"},{"location":"community_level/nestedness/#nodf","title":"NODF","text":""},{"location":"getting_started/demonstration/","title":"Building a network","text":""},{"location":"getting_started/demonstration/#building-a-network","title":"Building a network","text":"<p>Abstract</p> <p>Before getting started with the package itself, we will see how we can build a network, access its content, and iterate over the interactions. This page is intended to give you some intuitions about how the type system works, before reading more of the manual.</p> <pre><code>using SpeciesInteractionNetworks\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-species","title":"List of species","text":"<p>We will create a very small network, made of four species and their interactions. The first step is to define a list of species:</p> <pre><code>species = [:fox, :vole, :hawk, :turnip]\n</code></pre> <pre><code>4-element Vector{Symbol}:\n :fox\n :vole\n :hawk\n :turnip\n</code></pre> <p>In order to make sure that we are explicit about the type of network we are working with, we will create a representation of this list of species that is unipartite:</p> <pre><code>nodes = Unipartite(species)\n</code></pre> <pre><code>Unipartite{Symbol}([:fox, :vole, :hawk, :turnip])\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#list-of-interactions","title":"List of interactions","text":"<p>As with species, we want to represent interactions in a way that captures ecological information. In this case, we will use binary interactions (true/0), and work from a matrix, where the rows are the source of the interaction, and the column is its destination. It means that interactions go from predator to preys.</p> <pre><code>int_matrix = Bool[\n0 1 0 0;\n0 0 0 1;\n0 1 0 0;\n0 0 0 0\n]\n</code></pre> <pre><code>4\u00d74 Matrix{Bool}:\n 0  1  0  0\n 0  0  0  1\n 0  1  0  0\n 0  0  0  0\n</code></pre> <p>About interaction as matrices</p> <p>By specifying interactions as a matrix, it is fundamental that columns and orders are in the correct order. There are alternative ways to specify networks that do not rely on matrices (using tuples or pairs), but because most species interaction network data are represented as matrices, this is supported by the package.</p> <p>As this network is binary, we will wrap this matrix into a <code>Binary</code> collection of interactions:</p> <pre><code>edges = Binary(int_matrix)\n</code></pre> <pre><code>Binary{Bool}(sparse([1, 3, 2], [2, 2, 4], Bool[1, 1, 1], 4, 4))\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#assembling-the-network","title":"Assembling the network","text":"<p>The network itself is a collection of nodes and edges. There are a number of specific checks performed when creating the network, to ensure that we cannot create an object that makes no sense.</p> <pre><code>network = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Unipartite{Symbol}, Binary{Bool}}(Unipartite{Symbol}([:fox, :vole, :hawk, :turnip]), Binary{Bool}(sparse([1, 3, 2], [2, 2, 4], Bool[1, 1, 1], 4, 4)))\n</code></pre> <p>The networks are iterable, i.e. we can walk through them, specifically one interaction at a time:</p> <pre><code>for interaction in network\nprintln(interaction)\nend\n</code></pre> <pre><code>(:fox, :vole, true)\n(:hawk, :vole, true)\n(:vole, :turnip, true)\n</code></pre> <p>Internally, this is done by only returning the pairs of species that do not have a value of zero.</p> <p></p> <p></p>"},{"location":"getting_started/demonstration/#basics-of-network-exploration","title":"Basics of network exploration","text":"<p>We can also get a list of the species that establish an interaction with a given species (in this case, predators):</p> <pre><code>predecessors(network, :vole)\n</code></pre> <pre><code>Set{Symbol} with 2 elements:\n  :fox\n  :hawk\n</code></pre> <p>Or the species witch which a given species establishes interactions (in this case, preys):</p> <pre><code>successors(network, :fox)\n</code></pre> <pre><code>Set{Symbol} with 1 element:\n  :vole\n</code></pre> <p>Further</p> <pre><code>interactions(subgraph(network, [:fox, :vole, :turnip]))\n</code></pre> <pre><code>2-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-editable","title":"Networks are editable","text":"<p>The content of networks can be modified. For example, to circumvent the issue of needing to write the interaction matrix in the correct order, we can start with an empty network:</p> <pre><code>netsize = (richness(nodes,1), richness(nodes, 2))\nedges2 = Binary(zeros(Bool, netsize))\nnetwork2 = SpeciesInteractionNetwork(nodes, edges2)\ninteractions(network2)\n</code></pre> <pre><code>Tuple{Symbol, Symbol, Bool}[]\n</code></pre> <p>We can then add the interactions one by one:</p> <pre><code>for interaction in [(:fox, :vole), (:hawk, :vole), (:vole, :turnip)]\nnetwork2[interaction...] = true\nend\ninteractions(network2)\n</code></pre> <pre><code>3-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:fox, :vole, 1)\n (:hawk, :vole, 1)\n (:vole, :turnip, 1)\n</code></pre> <p></p> <p></p>"},{"location":"getting_started/demonstration/#networks-are-tables","title":"Networks are tables","text":"<p>All of the networks can be converted to a tabular data, for use with e.g. the <code>DataFrames</code> package:</p> <pre><code>import DataFrames\nDataFrames.DataFrame(network)\n</code></pre> 3\u00d73 DataFrame Row123SymbolSymbolBool1foxvoletrue2hawkvoletrue3voleturniptrue"},{"location":"getting_started/types/","title":"Type system","text":""},{"location":"getting_started/types/#the-type-system","title":"The type system","text":"<p>The package relies on a compreensive system of types to represent networks. The purpose of the type system is to ensure that data are represented without ambiguities, but also to specialize the algorithm applied to each type of network.</p> <p>The networks are represented as sparse matrices, for performance reasons. In practice, networks are standard Julia arrays, in that they can be accessed by position, sliced, have a <code>size</code> and <code>axes</code>, etc..</p> <p># <code>SpeciesInteractionNetworks.SpeciesInteractionNetwork</code> \u2014 Type.</p> <pre><code>SpeciesInteractionNetwork{P&lt;:Partiteness, E&lt;:Interactions}\n</code></pre> <p>A <code>SpeciesInteractionNetwork</code> type represents a species interaction network.</p> <p>This type has two fields: <code>nodes</code> (a <code>Partiteness</code>), and <code>edges</code> (an <code>Interactions</code>). Because these two types are parametric, we can learn everything there is to know about the data structure in a network by looking at the type alone.</p> <p>For example, a bipartite quantitative network where species are symbols and interactions are 32-bits floating point numbers will have the type</p> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Interactions{Float32}}\n</code></pre> <p>This enables very specialized dispatch and indexing thoughout the package.</p> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-species","title":"Representing species","text":"<p># <code>SpeciesInteractionNetworks.Partiteness</code> \u2014 Type.</p> <pre><code>Partiteness{T}\n</code></pre> <p>The species in a network are stored in a parametric sub-type of <code>Partiteness</code>. By default, this can be <code>Unipartite</code> or <code>Bipartite</code>. The inner type <code>T</code> indicates what types can be used to represent species. Note that species cannot be represented as integers, and will instead have a name. We recommend using strings or symbols.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Bipartite</code> \u2014 Type.</p> <pre><code>Bipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A bipartite set of species is represented by two sets of species, called <code>top</code> and <code>bottom</code>. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>top</code> must be unique</li> <li>All species in <code>bottom</code> must be unique</li> <li>No species can be found in both <code>bottom</code> and <code>top</code></li> </ol> <p>source</p> <p># <code>SpeciesInteractionNetworks.Unipartite</code> \u2014 Type.</p> <pre><code>Unipartite{T &lt;: Any} &lt;: Partiteness{T}\n</code></pre> <p>A unipartite set of species is represented by a single set of species, called <code>margin</code> internally. Both set of species are represented as <code>Vector{T}</code>, with a few specific constraints:</p> <ol> <li><code>T</code> cannot be a <code>Number</code> (i.e. nodes must have names, or be other objects)</li> <li>All species in <code>margin</code> must be unique</li> </ol> <p>source</p> <p></p> <p></p>"},{"location":"getting_started/types/#representing-interactions","title":"Representing interactions","text":"<p># <code>SpeciesInteractionNetworks.Interactions</code> \u2014 Type.</p> <pre><code>Interactions{T}\n</code></pre> <p>The interactions in a network are stored in a parametric sub-type of <code>Interactions</code>. By default, this can be <code>Binary</code>, <code>Quantitative</code>, and <code>Probabilistic</code>. The inner type <code>T</code> indicates what types are used to represent interactions.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Binary</code> \u2014 Type.</p> <pre><code>Binary{Bool} &lt;: Interactions{Bool}\n</code></pre> <p>Binary interactions are represented (internally) as a sparse matrix of Boolean values.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Quantitative</code> \u2014 Type.</p> <pre><code>Quantitative{T &lt;: Number} &lt;: Interactions{T}\n</code></pre> <p>Quantitative interactions are represented (internally) as a sparse matrix of numbers.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.Probabilistic</code> \u2014 Type.</p> <pre><code>Probabilistic{T &lt;: AbstractFloat} &lt;: Interactions{T}\n</code></pre> <p>Probabilistic interactions are represented (internally) as a sparse matrix of floating point values. The values must be in the unit interval for the type to be valid.</p> <p>source</p>"},{"location":"meso_level/paths/","title":"Paths","text":""},{"location":"meso_level/paths/#paths","title":"Paths","text":"<p>Abstract</p> <p>These functions help with path manipulation, and in particular the identification of shortest paths between any two nodes.</p> <p></p> <p></p>"},{"location":"meso_level/paths/#shortest-path-calculation","title":"Shortest path calculation","text":"<p># <code>SpeciesInteractionNetworks.shortestpath</code> \u2014 Function.</p> <pre><code>shortestpath(::Type{BellmanFord}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary,Quantitative}}, source)\n</code></pre> <p>Uses the Bellman-Ford algorithm ...</p> <p>For binary networks, all interactions incur a distance of one. For quantitative networks, an interaction with edge weight w incurs a distance of w\u207b\u00b2, so that strong interactions pull nodes together.</p> <p>source</p>"},{"location":"random_networks/permutations/","title":"Permutations","text":""},{"location":"random_networks/permutations/#permutations-of-networks","title":"Permutations of networks","text":"<p>Abstract</p> <p>The methods presented in this page perform network permutation, i.e. they move interactions around while also respecting a number of constraints. Permutations are used in null hypothesis testing, or can be used alongside e.g. simulated annealing to bring networks closer to a specified structure.</p> <p>The functions for permutations are using an edge-swap algorithm, in which the endpoint of interactions is switched to re-wire the network without changing the degree distribution. Each call to the <code>swap!</code> function will modify the network, and perform a single edge swap.</p> <p>Maximum iterations when doing permutations</p> <p>Every permutation will try up to <code>SpeciesInteractionNetworks.SWAP_MAXITER</code> times (defaults to 100) to find a suitable pair of edges to swap, and then return the network unshuffled if they failed to find a suitable pair of edges to swap. This value can be changed.</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-constraints","title":"Permutation constraints","text":"<p>Permutations are constrained, in that we can guarantee that the resulting network may have structural properties that are similar to the original network. The type of constraint we apply is determined by the <code>PermutationConstrant</code> enumerated type.</p> <p># <code>SpeciesInteractionNetworks.PermutationConstraint</code> \u2014 Type.</p> <pre><code>PermutationConstraint\n</code></pre> <p>The <code>PermutationConstraint</code> specifies which structural constraint is enforced. It is defined as an abstract type, and the subtypes can be passed as the second argument to <code>swap!</code>.</p> <p>Currently supported constraints are <code>Degree</code> (degree distribution is maintained), <code>Generality</code> (number of out-going links is maintained), <code>Vulnerability</code> (number of in-going links is maintained), and <code>Connectance</code> (only the connectance is maintained). Note that in addition, species cannot become disconnected, even if the constraint is not acting on the degree / degree distribution.</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#permutation-of-a-network","title":"Permutation of a network","text":"<p>Note that the permutations are currently limited to networks with <code>Binary</code> interactions.</p> <p># <code>SpeciesInteractionNetworks.swap!</code> \u2014 Function.</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary})\n</code></pre> <p>Performs one swap of interactions in the network. If no <code>PermutationConstraint</code> is given as a second argument, the degree distribution of all species will be maintained.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Degree})\n</code></pre> <p>Permutations with a constraint by degree work by picking two interacting species pairs, (r1, s1) and (r2, s2), and trying to replace them by (r1, s2) and (r2, s1).</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Generality})\n</code></pre> <p>Permutations with a constraint by degree work by picking one interacting species pair, (r1, s1), and a new stem species s3, trying to replace them by (r1, s3). This function only applies if the result of this permutations does not remove the last incoming link from s1.</p> <p>source</p> <pre><code>swap!(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Binary}, ::Type{Connectance})\n</code></pre> <p>Permutations with a constraint by connectance will randomly (and with equal probability) perform a move that is constrained by degree, generality, or vulnerability.</p> <p>source</p> <p></p> <p></p>"},{"location":"random_networks/permutations/#illustration","title":"Illustration","text":"<p>To showcase <code>swap!</code> in practice, we will work through through a simple example of (i) generating a perfectly nested network, (ii) shuffling interactions by maintaining the generality of top-level species, and (iii) looking at the way the nestdeness of the entire network changes with each successive swap.</p> <pre><code>using SpeciesInteractionNetworks\nimport CairoMakie\n</code></pre> <p>We can generate a nested network rather easily, by creating a matrix of binary interactions, where the species interact with species from a lower rank:</p> <pre><code>A = zeros(Bool, (10, 14))\nfor i in axes(A, 1)\nfor j in axes(A, 2)\nif i &lt;= j\nA[i,j] = true\nend\nend\nend\n</code></pre> <p>We can declare a network without having to define all of the species, by first wrapping our matrix inside a <code>Binary</code> type, and then generating a <code>Bipartite</code> species set with the right number of species:</p> <pre><code>edges = Binary(A)\nnodes = Bipartite(edges)\nN = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Binary{Bool}}(Bipartite{Symbol}([:top_1, :top_2, :top_3, :top_4, :top_5, :top_6, :top_7, :top_8, :top_9, :top_10], [:bottom_1, :bottom_2, :bottom_3, :bottom_4, :bottom_5, :bottom_6, :bottom_7, :bottom_8, :bottom_9, :bottom_10, :bottom_11, :bottom_12, :bottom_13, :bottom_14]), Binary{Bool}(sparse([1, 1, 2, 1, 2, 3, 1, 2, 3, 4  \u2026  1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10, 14)))\n</code></pre> <p>The initial nestedness of this network, measured using \u03b7 is (network, top-level contribution, bottom-level contribution):</p> <pre><code>(\u03b7(N), \u03b7(N,1), \u03b7(N,2))\n</code></pre> <pre><code>(1.0, 1.0, 1.0)\n</code></pre> <p>In order to generate the series of successive permutations, we will define an empty array of values, and then for each successive step, calculate the nestedness of the network, and then swap interactions under the given constraint.</p> <pre><code>nestedness_series = zeros(Float64, 1000)\nfor i in axes(nestedness_series, 1)\nnestedness_series[i] = \u03b7(N)\nswap!(N, Generality)\nend\n</code></pre> <p>A note about swaps and underlying nodes/edges</p> <p>When we perform the <code>swap!</code> operation, we are modifying the network (this is what we want!), but we are also modifying the <code>edges</code> object. If you want to re-use the edges in another network, be mindful of the fact that this will be the randomized edges. See <code>copy</code> for a way to create new copies of a network.</p> <p>Finally, we can plot the result, to check that 1000 swaps are enough to bring us to some sort of equilibrium of the randomized nestedness:</p> <pre><code>f = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Swap\", ylabel = \"Nestedness\")\nCairoMakie.lines!(ax, nestedness_series, color=(:black, 0.5))\nCairoMakie.tightlimits!(ax)\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"species_level/centrality/","title":"Centrality","text":""},{"location":"species_level/centrality/#measures-of-centrality","title":"Measures of centrality","text":"<p>Abstract</p> <p>Centrality can help in quantifying the importance of species in a network. These function will measure the centrality of all species under different algorithms. There is a single wrapper function called <code>centrality</code>, which uses an optional first argument to specify the algorithm to use.</p> <p>The centrality scores are returned so that they sum to one. This is intended to make sure that within a network, the values for different nodes are comparable.</p> <p></p> <p></p>"},{"location":"species_level/centrality/#implemented-algorithms","title":"Implemented algorithms","text":"<p># <code>SpeciesInteractionNetworks.CentralityMethod</code> \u2014 Type.</p> <pre><code>CentralityMethod\n</code></pre> <p>All algorithms for centrality are subtypes of <code>CentralityMethod</code>. These algorithms do not take additional arguments, which are instead passed to the <code>centrality</code> method.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.KatzCentrality</code> \u2014 Type.</p> <pre><code>KatzCentrality\n</code></pre> <p>This type is used to perform the Katz centrality analysis.</p> <p>References</p> <p>Leo Katz (1953)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.EigenvectorCentrality</code> \u2014 Type.</p> <pre><code>EigenvectorCentrality\n</code></pre> <p>This type is used to perform the Eigenvector centrality analysis.</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.ClosenessCentrality</code> \u2014 Type.</p> <pre><code>ClosenessCentrality\n</code></pre> <p>Closeness centrality is defined as the reciprocal of farness, i.e. 1 over the sum of shortest paths from the source node to all other nodes. In the case of probabilistic networks, we use the random walk approximation of closeness centrality, where the distance is defined as first passage time.</p> <p>References</p> <p>Alex Bavelas (1950)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.ResidualClosenessCentrality</code> \u2014 Type.</p> <pre><code>ResidualClosenessCentrality\n</code></pre> <p>References</p> <p>Chavdar Dangalchev (2006)</p> <p>source</p> <p># <code>SpeciesInteractionNetworks.GeneralizedClosenessCentrality</code> \u2014 Type.</p> <pre><code>GeneralizedClosenessCentrality\n</code></pre> <p>References</p> <p>Chavdar Dangalchev (2011)</p> <p>source</p> <p></p> <p></p>"},{"location":"species_level/centrality/#centrality-function","title":"Centrality function","text":"<p># <code>SpeciesInteractionNetworks.centrality</code> \u2014 Function.</p> <pre><code>centrality(N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary, Probabilistic}})\n</code></pre> <p>If no type is given as the first argument, the centrality function will use <code>ClosenessCentrality</code>.</p> <p>source</p> <pre><code>centrality(::Type{ClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Probabilistic})\n</code></pre> <p>The closeness centrality of a probabilistic network is measured using the random walk closeness centrality, where the distance between two nodes i and j is measured as the first passage time on node j of a random walk starting on node i. This function does not look for shortest paths, and is therefore reasonably fast.</p> <p>source</p> <pre><code>centrality(::Type{ClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary})\n</code></pre> <p>The closeness centrality of a binary network is the reciprocal of the sum of shortest paths.</p> <p>source</p> <pre><code>centrality(::Type{ResidualClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary})\n</code></pre> <p>The residual closeness centrality of a binary network is the sum of the residuals of two to the power of the length of shortest paths.</p> <p>source</p> <pre><code>centrality(::Type{GeneralizedClosenessCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Binary}; \u03b1=0.1)\n</code></pre> <p>The generalized closeness centrality of a binary network ranges from the degree centrality (\u03b1 is 0) to the number of reachable nodes (\u03b1=1).</p> <p>source</p> <pre><code>centrality(::Type{KatzCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Union{Binary, Probabilistic}}; \u03b1::AbstractFloat=0.1)\n</code></pre> <p>This measure gives a different weight to every subsequent connection (<code>\u03b1</code>). <code>\u03b1</code> is a weight, specifically the attenuation of each subsequent move away from the node, and therefore must be positive.</p> <p>Note that internally, this function uses linear algebra shortcuts (rather than a sum over path lengths) to calculate the centrality, which is faster. As a consequence, there is, for each network, a maximal value of \u03b1 that is the reciprocal of the absolute value of the leading eigenvalue of the adjacency matrix. This \u03b1 has no analytical solution when the adjacency matrix has complex eigenvalues. It is recommended to use this centrality algorithm as part of a <code>try</code>/<code>catch</code> block if using large values of \u03b1.</p> <p>References</p> <p> (2008)</p> <p>source</p> <pre><code>centrality(::Type{EigenvectorCentrality}, N::SpeciesInteractionNetwork{&lt;:Unipartite, &lt;:Interactions})\n</code></pre> <p>Eigencentrality, corrected so that the centralities in the network sum to one.</p> <p>The eigenvector centrality is calculated using Von Mises iteration, starting from a random vector.</p> <p>where A is the adjacency matrix of the graph, b is the vector of centralities, At each iteration, the vector is updated to be A\u00d7b/|A\u00d7b|, and |\u22c5| is the norm.</p> <p>The number of iterations is determined by the variable <code>SpeciesInteractionNetworks.CENTRALITY_MAXITER</code>, and the algorithm usually converges rapidly.</p> <p>References</p> <p>Edmund Landau (1895)</p> <p>source</p> <p></p> <p></p>"},{"location":"species_level/centrality/#illustration","title":"Illustration","text":"<pre><code>using SpeciesInteractionNetworks\n\nnodes = Unipartite([:Wyeomyia, :Metriocnemus, :Fletcherimyia, :Habrotrocha, :Protozoa, :Sarraceniopus, :Bacteria, :Insects])\nedges = Binary(zeros(Bool, (richness(nodes), richness(nodes))))\nN = SpeciesInteractionNetwork(nodes, edges)\n\nN[:Metriocnemus, :Insects] = true\nN[:Fletcherimyia, :Insects] = true\nN[:Bacteria, :Insects] = true\nN[:Sarraceniopus, :Bacteria] = true\nN[:Habrotrocha, :Bacteria] = true\nN[:Protozoa, :Bacteria] = true\nN[:Protozoa, :Habrotrocha] = true\nN[:Wyeomyia, :Habrotrocha] = true\nN[:Wyeomyia, :Protozoa] = true\nN[:Wyeomyia, :Bacteria] = true\n\ninteractions(N)\n</code></pre> <pre><code>10-element Vector{Tuple{Symbol, Symbol, Bool}}:\n (:Wyeomyia, :Habrotrocha, 1)\n (:Protozoa, :Habrotrocha, 1)\n (:Wyeomyia, :Protozoa, 1)\n (:Wyeomyia, :Bacteria, 1)\n (:Habrotrocha, :Bacteria, 1)\n (:Protozoa, :Bacteria, 1)\n (:Sarraceniopus, :Bacteria, 1)\n (:Metriocnemus, :Insects, 1)\n (:Fletcherimyia, :Insects, 1)\n (:Bacteria, :Insects, 1)\n</code></pre> <p>change alpha</p> <pre><code>attenuation = 10.0.^LinRange(-1, 0, 20)\nc_insect = zeros(length(attenuation))\nc_bacteria = zeros(length(attenuation))\nc_protozoa = zeros(length(attenuation))\nfor (i,\u03b1) in enumerate(attenuation)\nci = centrality(KatzCentrality, N; \u03b1=\u03b1)\nc_insect[i] = ci[:Insects]\nc_bacteria[i] = ci[:Bacteria]\nc_protozoa[i] = ci[:Protozoa]\nend\n</code></pre> <p>plot</p> <pre><code>import CairoMakie\n\nf = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Attenuation\", ylabel = \"Centrality\", xscale=log10)\nCairoMakie.lines!(ax, attenuation, c_insect, color=(:black, 0.5), label=\"Insect\")\nCairoMakie.lines!(ax, attenuation, c_bacteria, color=(:green, 0.5), label=\"Bacteria\")\nCairoMakie.lines!(ax, attenuation, c_protozoa, color=(:orange, 0.5), label=\"Protozoa\")\nCairoMakie.tightlimits!(ax)\nCairoMakie.axislegend(position=:lb)\nCairoMakie.current_figure()\n</code></pre> <p></p> <p>same with closeness centrality</p> <pre><code>attenuation = 10.0.^LinRange(-1, 0, 20)\nc_insect = zeros(length(attenuation))\nc_bacteria = zeros(length(attenuation))\nc_protozoa = zeros(length(attenuation))\nfor (i,\u03b1) in enumerate(attenuation)\nci = centrality(GeneralizedClosenessCentrality, N; \u03b1=\u03b1)\nc_insect[i] = ci[:Insects]\nc_bacteria[i] = ci[:Bacteria]\nc_protozoa[i] = ci[:Protozoa]\nend\n</code></pre> <p>plot</p> <pre><code>import CairoMakie\n\nf = CairoMakie.Figure(backgroundcolor = :transparent, resolution = (800, 300))\nax = CairoMakie.Axis(f[1,1], xlabel=\"Attenuation\", ylabel = \"Centrality\", xscale=log10)\nCairoMakie.lines!(ax, attenuation, c_insect, color=(:black, 0.5), label=\"Insect\")\nCairoMakie.lines!(ax, attenuation, c_bacteria, color=(:green, 0.5), label=\"Bacteria\")\nCairoMakie.lines!(ax, attenuation, c_protozoa, color=(:orange, 0.5), label=\"Protozoa\")\nCairoMakie.tightlimits!(ax)\nCairoMakie.axislegend(position=:lb)\nCairoMakie.current_figure()\n</code></pre> <p></p>"},{"location":"species_level/specificity/","title":"Specificity","text":""},{"location":"species_level/specificity/#specificity","title":"Specificity","text":"<p>Abstract</p> <p>The specificity of species in a network is measured either as a function of the proportion of resouces they effectively use (for binary networks), or as a function of the distribution of their performance on these resources (for quantitative networks).</p> <p></p> <p></p>"},{"location":"species_level/specificity/#measures-of-specificity","title":"Measures of specificity","text":"<p>The packages relies on the Paired Difference Index to calculate specificity, as it can be applied to both binary and quantitative data.</p> <p># <code>SpeciesInteractionNetworks.specificity</code> \u2014 Function.</p> <pre><code>specificity(N::SpeciesInteractionNetwork{&lt;:Partiteness, &lt;:Union{Binary,Quantitative}})\n</code></pre> <p>For a deterministic network, this function will return a dictionary mapping each top-level species to its specificity. The same index (Paired Differences Index) is used for binary and quantitative networks. A value of one corresponds to maximum specialism, and a value of zero to maximum generalism. The index is symmetrical, so that a species with a value of one half is neither specialist nor generalist.</p> <p>References</p> <p>Timoth\u00e9e Poisot, Elsa Canard, Nicolas Mouquet, Michael E. Hochberg (2012)</p> <p>source</p> <p></p> <p></p>"},{"location":"species_level/specificity/#illustration","title":"Illustration","text":"<p>We can generate an example network with three different degrees of specificity:</p> <pre><code>using SpeciesInteractionNetworks\n\nnodes = Bipartite([:A, :B, :C, :D, :E], [:a, :b, :c, :d, :e, :f])\nedges = Quantitative([1 0 0 0 0; 2 0 0 0 0; 1 1 1 0 0; 4 3 2 1 0; 4 4 4 3 0])\nN = SpeciesInteractionNetwork(nodes, edges)\n</code></pre> <pre><code>SpeciesInteractionNetwork{Bipartite{Symbol}, Quantitative{Int64}}(Bipartite{Symbol}([:A, :B, :C, :D, :E], [:a, :b, :c, :d, :e, :f]), Quantitative{Int64}(sparse([1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5, 4, 5], [1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4], [1, 2, 1, 4, 4, 1, 3, 4, 1, 2, 4, 1, 3], 5, 5)))\n</code></pre> <p>We can calculate the specificity of the top-level species:</p> <pre><code>spe_scores = specificity(N)\n</code></pre> <pre><code>Dict{Symbol, Float64} with 5 entries:\n  :A =&gt; 1.0\n  :D =&gt; 0.625\n  :B =&gt; 1.0\n  :E =&gt; 0.3125\n  :C =&gt; 0.5\n</code></pre> <p>The output of specificity is a dictionary, where the <code>species(N, 1)</code> are keys, and the score for each of these species are the values. We can, for example, look at the specificity for species <code>:D</code>:</p> <pre><code>spe_scores[:D]\n</code></pre> <pre><code>0.625\n</code></pre> <p>Making sense of the score</p> <p>The Paired Differences Index will always return values in the unit interval, and these values are independent from one species to the next. In the example above, species <code>:A</code> and <code>:B</code> have the same (maximum) specificity because they use a single resource. The purpose of the Paired Differences Index is to express specificity in a way that is not affected by the total interaction strenght of the species, because what is well understood can be measured without confounders.</p> <p>As always, keep in mind that the ordering of keys in the dictionary is not fixed. Therefore, it is probably safer to iterate over the <code>species(N, 1)</code> when looking for specific values.</p>"}]}